{"version":3,"file":"js/background.js","mappings":";;;;;;;;;;AAAa;;AAEb,YAAY,mBAAO,CAAC,mEAAY;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;;AAEzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA,aAAa;AACb,cAAc;AACd,eAAe;AACf,eAAe;;;;;;;;;;;ACxFF;;AAEb;AACA;AACA;AACA;;AAEA,eAAe;;AAEf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,cAAc;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,WAAW,iBAAiB;AAC5B;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,mBAAmB;AACjE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,MAAM;AACjB,aAAa,YAAY;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,oCAAoC;AACpC,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,GAAG,IAAI,EAAE;AAC9C;AACA;AACA;AACA,iCAAiC,GAAG,4BAA4B,GAAG;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA,aAAa,gEAAgE;AAC7E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,KAAK;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK,0BAA0B,KAAK;AACpC,uBAAuB,6BAA6B;AACpD;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAgD;AACxE;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,GAAG,UAAU,GAAG,gBAAgB,EAAE;AACpD;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qCAAqC;AACrC;AACA;AACA;AACA;AACA,uBAAuB,8CAA8C;AACrE;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,uBAAuB,8CAA8C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA,sBAAsB;AACtB,aAAa;AACb;AACA;AACA,EAAE;;AAEF;AACA,WAAW;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI,uBAAuB;AAC3B;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,EAAE;;AAEF;AACA;AACA,WAAW;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,WAAW;AACX,EAAE;;AAEF;AACA;AACA;AACA,kCAAkC;AAClC;AACA,oBAAoB;AACpB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;;AAEjB,WAAW;AACX,EAAE;;AAEF;AACA;AACA;AACA,0BAA0B,EAAE,GAAG,GAAG,WAAW,GAAG,oBAAoB,EAAE,gBAAgB,EAAE;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,SAAS,6BAA6B;AACtC,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,kDAAkD;AAClD;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,uCAAuC;AACvC;AACA;AACA,EAAE;;AAEF;AACA;AACA,qDAAqD;AACrD;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA,4CAA4C;AAC5C,EAAE;;AAEF;AACA;AACA;AACA,IAAI;AACJ;AACA,6BAA6B;AAC7B;AACA,eAAe;AACf;AACA,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA,EAAE;AACF;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA,aAAa;AACb,cAAc;;;;;;;;;;;ACvyFd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,IAAI,gBAAgB;AACpB;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,IAAI,GAAG,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B,kCAAkC,IAAI;AACtC,kCAAkC,IAAI;AACtC;AACA,4BAA4B,IAAI,MAAM,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,GAAG,EAAE;AACrC;AACA;AACA,yCAAyC,IAAI,kBAAkB,IAAI,MAAM;AACzE,4CAA4C,IAAI,kBAAkB,IAAI,MAAM;AAC5E,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,IAAI,EAAE,KAAK;AACxD,gDAAgD,IAAI,yBAAyB,aAAa,IAAI;AAC9F,wCAAwC,IAAI,yBAAyB,SAAS,GAAG,SAAS,GAAG,WAAW,GAAG;AAC3G,iDAAiD,IAAI,yBAAyB;AAC9E,kDAAkD,IAAI,yBAAyB;AAC/E,+CAA+C,IAAI,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA,0BAA0B,EAAE,GAAG,IAAI;AACnC,mBAAmB,IAAI,GAAG,GAAG,sBAAsB,GAAG,6CAA6C,IAAI;AACvG,eAAe,IAAI,aAAa,GAAG,aAAa,GAAG,cAAc,GAAG;AACpE,oBAAoB,IAAI,GAAG,IAAI;AAC/B,4BAA4B,IAAI;AAChC,8JAA8J,IAAI;AAClK;AACA;AACA,iCAAiC,EAAE,GAAG,IAAI;AAC1C,2BAA2B,IAAI,KAAK,GAAG,GAAG,GAAG;AAC7C,+BAA+B,IAAI;AACnC,4BAA4B,IAAI,EAAE,IAAI;AACtC,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA,iCAAiC,EAAE,GAAG,IAAI;AAC1C,2BAA2B,IAAI,KAAK,GAAG,GAAG,GAAG;AAC7C,+BAA+B,IAAI;AACnC,4BAA4B,IAAI,EAAE,IAAI;AACtC,yBAAyB,IAAI;AAC7B,0BAA0B,IAAI;AAC9B;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,EAAE,IAAI;AACrC;AACA;AACA,8BAA8B,IAAI;AAClC,0BAA0B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC3D,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,2BAA2B,IAAI,EAAE,IAAI;AACrC,8BAA8B,IAAI;AAClC,2BAA2B,EAAE,GAAG,IAAI;AACpC,0BAA0B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC3D,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,EAAE,IAAI;AACzC;AACA;AACA,kCAAkC,IAAI;AACtC,8BAA8B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC/D,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,GAAG;AAC9C,oEAAoE,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI;AACtB;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe,EAAE;AAC1D;AACA,gBAAgB,GAAG;AACnB,sCAAsC,GAAG,8CAA8C,GAAG;AAC1F;AACA,0BAA0B,EAAE,GAAG,EAAE;AACjC,mCAAmC,EAAE,GAAG,EAAE;AAC1C,uCAAuC,EAAE,GAAG,EAAE;AAC9C;AACA;AACA;AACA,0CAA0C,EAAE,GAAG,EAAE;AACjD,mDAAmD,EAAE,GAAG,EAAE;AAC1D,qDAAqD,EAAE,GAAG,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD,iDAAiD,EAAE,kCAAkC,KAAK,6CAA6C,KAAK;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC,UAAU;AAC5E;AACA,iCAAiC,GAAG,iCAAiC,GAAG,6EAA6E,GAAG,+BAA+B,GAAG,gCAAgC,GAAG;AAC7N;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA,iCAAiC,GAAG;AACpC,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,IAAI,WAAW;AAClD,iCAAiC,KAAK,IAAI,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI,IAAI,eAAe,SAAS,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,sDAAsD;AACtD;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mIAAmI;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,EAAE,GAAG,GAAG;AAC5D;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,gCAAgC,KAAK;AACrC;AACA,WAAW,MAAM;AACjB;AACA;AACA,cAAc,eAAe;AAC7B,oBAAoB,MAAM,GAAG,gCAAgC,KAAK,MAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM,SAAS,YAAY;AAC7C,kBAAkB,KAAK;AACvB,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,0BAA0B,gCAAgC;AAC1D;AACA,SAAS,QAAQ;AACjB,sBAAsB,gCAAgC;AACtD;AACA,eAAe,MAAM;AACrB,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,uBAAuB,gCAAgC;AACvD;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,SAAS,KAAK;AAClD;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,wFAAwF,cAAc;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAoD;AAC3F,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,oFAAoF,cAAc;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,SAAS;AACT;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb,aAAa;AACb,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,oBAAoB;AACpB,iBAAiB;AACjB,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","sources":["webpack://Toolkit-for-VIEW/./node_modules/angular-expressions/lib/main.js","webpack://Toolkit-for-VIEW/./node_modules/angular-expressions/lib/parse.js","webpack://Toolkit-for-VIEW/./node_modules/marked/lib/marked.cjs","webpack://Toolkit-for-VIEW/./src/js/VIEWsubmit.ts","webpack://Toolkit-for-VIEW/./src/js/emailmaker.ts","webpack://Toolkit-for-VIEW/./src/js/genLetter-module.ts","webpack://Toolkit-for-VIEW/./src/js/letter-logic.ts","webpack://Toolkit-for-VIEW/webpack/bootstrap","webpack://Toolkit-for-VIEW/webpack/runtime/compat get default export","webpack://Toolkit-for-VIEW/webpack/runtime/define property getters","webpack://Toolkit-for-VIEW/webpack/runtime/hasOwnProperty shorthand","webpack://Toolkit-for-VIEW/webpack/runtime/make namespace object","webpack://Toolkit-for-VIEW/./src/background.js"],"sourcesContent":["\"use strict\";\n\nvar parse = require(\"./parse.js\");\n\nvar filters = {};\nvar Lexer = parse.Lexer;\nvar Parser = parse.Parser;\n\nfunction addOptionDefaults(options) {\n\toptions = options || {};\n\tif (options.filters) {\n\t\toptions.cache = options.cache || {};\n\t}\n\toptions.cache = options.cache || compile.cache;\n\toptions.filters = options.filters || filters;\n\treturn options;\n}\n\nfunction getParserOptions(options) {\n\treturn {\n\t\thandleThis: options.handleThis != null ? options.handleThis : true,\n\t\tcsp: options.csp != null ? options.csp : false, // noUnsafeEval,\n\t\tliterals:\n\t\t\toptions.literals != null\n\t\t\t\t? options.literals\n\t\t\t\t: {\n\t\t\t\t\t\t// defined at: function $ParseProvider() {\n\t\t\t\t\t\ttrue: true,\n\t\t\t\t\t\tfalse: false,\n\t\t\t\t\t\tnull: null,\n\t\t\t\t\t\t/*eslint no-undefined: 0*/\n\t\t\t\t\t\tundefined: undefined,\n\t\t\t\t\t\t/* eslint: no-undefined: 1  */\n\t\t\t\t\t},\n\t};\n}\n\n/**\n * Compiles src and returns a function that executes src on a target object.\n * To speed up further calls the compiled function is cached under compile.cache[src] if options.filters is not present.\n *\n * @param {string} src\n * @param {object | undefined} options\n * @returns {function}\n */\nfunction compile(src, options) {\n\tif (typeof src !== \"string\") {\n\t\tthrow new TypeError(\n\t\t\t\"src must be a string, instead saw '\" + typeof src + \"'\"\n\t\t);\n\t}\n\toptions = addOptionDefaults(options);\n\tvar lexerOptions = options;\n\tvar parserOptions = getParserOptions(options);\n\n\tvar lexer = new Lexer(lexerOptions);\n\tvar parser = new Parser(\n\t\tlexer,\n\t\tfunction getFilter(name) {\n\t\t\treturn options.filters[name];\n\t\t},\n\t\tparserOptions\n\t);\n\n\tif (!options.cache) {\n\t\treturn parser.parse(src);\n\t}\n\tdelete options.src;\n\tvar cacheKey = JSON.stringify(Object.assign({ src: src }, options));\n\n\tvar cached = options.cache[cacheKey];\n\tif (!cached) {\n\t\tcached = options.cache[cacheKey] = parser.parse(src);\n\t}\n\treturn cached;\n}\n\n/**\n * A cache containing all compiled functions. The src is used as key.\n * Set this on false to disable the cache.\n *\n * @type {object}\n */\ncompile.cache = Object.create(null);\n\nexports.Lexer = Lexer;\nexports.Parser = Parser;\nexports.compile = compile;\nexports.filters = filters;\n","\"use strict\";\n\n/* eslint complexity: 0*/\n/* eslint eqeqeq: 0*/\n/* eslint func-style: 0*/\n/* eslint no-warning-comments: 0*/\n\nvar window = { document: {} };\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar lowercase = function (string) {\n\treturn isString(string) ? string.toLowerCase() : string;\n};\n\n/**\n * @ngdoc function\n * @name angular.isArray\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is an `Array`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Array`.\n */\nvar isArray = Array.isArray;\n\nvar manualLowercase = function (s) {\n\treturn isString(s)\n\t\t? s.replace(/[A-Z]/g, function (ch) {\n\t\t\t\treturn String.fromCharCode(ch.charCodeAt(0) | 32);\n\t\t\t})\n\t\t: s;\n};\n\n// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish\n// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods\n// with correct but slower alternatives. See https://github.com/angular/angular.js/issues/11387\nif (\"I\".toLowerCase() !== \"i\") {\n\tlowercase = manualLowercase;\n}\n\n// Run a function and disallow temporarly the use of the Function constructor\n// This makes arbitrary code generation attacks way more complicated.\nfunction runWithFunctionConstructorProtection(fn) {\n\tvar originalFunctionConstructor = Function.prototype.constructor;\n\tdelete Function.prototype.constructor;\n\tvar result = fn();\n\t// eslint-disable-next-line no-extend-native\n\tFunction.prototype.constructor = originalFunctionConstructor;\n\treturn result;\n}\n\nvar jqLite, // delay binding since jQuery could be loaded after us.\n\ttoString = Object.prototype.toString,\n\tgetPrototypeOf = Object.getPrototypeOf,\n\tngMinErr = minErr(\"ng\");\n\n/**\n * @private\n * @param {*} obj\n * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,\n *                   String ...)\n */\nfunction isArrayLike(obj) {\n\t// `null`, `undefined` and `window` are not array-like\n\tif (obj == null || isWindow(obj)) {\n\t\treturn false;\n\t}\n\n\t// arrays, strings and jQuery/jqLite objects are array like\n\t// * jqLite is either the jQuery or jqLite constructor function\n\t// * we have to check the existence of jqLite first as this method is called\n\t//   via the forEach method when constructing the jqLite object in the first place\n\tif (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite)) {\n\t\treturn true;\n\t}\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// \"length\" in obj used to prevent JIT error (gh-11508)\n\tvar length = \"length\" in Object(obj) && obj.length;\n\n\t// NodeList objects (with `item` method) and\n\t// other objects with suitable length characteristics are array-like\n\treturn (\n\t\tisNumber(length) &&\n\t\t((length >= 0 && (length - 1 in obj || obj instanceof Array)) ||\n\t\t\ttypeof obj.item === \"function\")\n\t);\n}\n\n/**\n * @ngdoc function\n * @name angular.forEach\n * @module ng\n * @kind function\n *\n * @description\n * Invokes the `iterator` function once for each item in `obj` collection, which can be either an\n * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`\n * is the value of an object property or an array element, `key` is the object property key or\n * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.\n *\n * It is worth noting that `.forEach` does not iterate over inherited properties because it filters\n * using the `hasOwnProperty` method.\n *\n * Unlike ES262's\n * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),\n * providing 'undefined' or 'null' values for `obj` will not throw a TypeError, but rather just\n * return the value provided.\n *\n   ```js\n     var values = {name: 'misko', gender: 'male'};\n     var log = [];\n     angular.forEach(values, function(value, key) {\n       this.push(key + ': ' + value);\n     }, log);\n     expect(log).toEqual(['name: misko', 'gender: male']);\n   ```\n *\n * @param {Object|Array} obj Object to iterate over.\n * @param {Function} iterator Iterator function.\n * @param {Object=} context Object to become context (`this`) for the iterator function.\n * @returns {Object|Array} Reference to `obj`.\n */\n\nfunction forEach(obj, iterator, context) {\n\tvar key, length;\n\tif (obj) {\n\t\tif (isFunction(obj)) {\n\t\t\tfor (key in obj) {\n\t\t\t\tif (\n\t\t\t\t\tkey !== \"prototype\" &&\n\t\t\t\t\tkey !== \"length\" &&\n\t\t\t\t\tkey !== \"name\" &&\n\t\t\t\t\tobj.hasOwnProperty(key)\n\t\t\t\t) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isArray(obj) || isArrayLike(obj)) {\n\t\t\tvar isPrimitive = typeof obj !== \"object\";\n\t\t\tfor (key = 0, length = obj.length; key < length; key++) {\n\t\t\t\tif (isPrimitive || key in obj) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (obj.forEach && obj.forEach !== forEach) {\n\t\t\tobj.forEach(iterator, context, obj);\n\t\t} else if (isBlankObject(obj)) {\n\t\t\t// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (key in obj) {\n\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t}\n\t\t} else if (typeof obj.hasOwnProperty === \"function\") {\n\t\t\t// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed\n\t\t\tfor (key in obj) {\n\t\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Slow path for objects which do not have a method `hasOwnProperty`\n\t\t\tfor (key in obj) {\n\t\t\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\n/**\n * Set or clear the hashkey for an object.\n * @param obj object\n * @param h the hashkey (!truthy to delete the hashkey)\n */\nfunction setHashKey(obj, h) {\n\tif (h) {\n\t\tobj.$$hashKey = h;\n\t} else {\n\t\tdelete obj.$$hashKey;\n\t}\n}\n\nfunction noop() {}\n\n/**\n * @ngdoc function\n * @name angular.isUndefined\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is undefined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is undefined.\n */\nfunction isUndefined(value) {\n\treturn typeof value === \"undefined\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isDefined\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is defined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is defined.\n */\nfunction isDefined(value) {\n\treturn typeof value !== \"undefined\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isObject\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\n * considered to be objects. Note that JavaScript arrays are objects.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Object` but not `null`.\n */\nfunction isObject(value) {\n\t// http://jsperf.com/isobject4\n\treturn value !== null && typeof value === \"object\";\n}\n\n/**\n * Determine if a value is an object with a null prototype\n *\n * @returns {boolean} True if `value` is an `Object` with a null prototype\n */\nfunction isBlankObject(value) {\n\treturn value !== null && typeof value === \"object\" && !getPrototypeOf(value);\n}\n\n/**\n * @ngdoc function\n * @name angular.isString\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `String`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `String`.\n */\nfunction isString(value) {\n\treturn typeof value === \"string\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isNumber\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `Number`.\n *\n * This includes the \"special\" numbers `NaN`, `+Infinity` and `-Infinity`.\n *\n * If you wish to exclude these then you can use the native\n * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)\n * method.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Number`.\n */\nfunction isNumber(value) {\n\treturn typeof value === \"number\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isFunction\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `Function`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Function`.\n */\nfunction isFunction(value) {\n\treturn typeof value === \"function\";\n}\n\n/**\n * Checks if `obj` is a window object.\n *\n * @private\n * @param {*} obj Object to check\n * @returns {boolean} True if `obj` is a window obj.\n */\nfunction isWindow(obj) {\n\treturn obj && obj.window === obj;\n}\n\nfunction isScope(obj) {\n\treturn obj && obj.$evalAsync && obj.$watch;\n}\n\nvar TYPED_ARRAY_REGEXP =\n\t/^\\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\\]$/;\nfunction isTypedArray(value) {\n\treturn (\n\t\tvalue &&\n\t\tisNumber(value.length) &&\n\t\tTYPED_ARRAY_REGEXP.test(toString.call(value))\n\t);\n}\n\nfunction isArrayBuffer(obj) {\n\treturn toString.call(obj) === \"[object ArrayBuffer]\";\n}\n/**\n * @ngdoc function\n * @name angular.copy\n * @module ng\n * @kind function\n *\n * @description\n * Creates a deep copy of `source`, which should be an object or an array.\n *\n * * If no destination is supplied, a copy of the object or array is created.\n * * If a destination is provided, all of its elements (for arrays) or properties (for objects)\n *   are deleted and then all elements/properties from the source are copied to it.\n * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.\n * * If `source` is identical to `destination` an exception will be thrown.\n *\n * <br />\n * <div class=\"alert alert-warning\">\n *   Only enumerable properties are taken into account. Non-enumerable properties (both on `source`\n *   and on `destination`) will be ignored.\n * </div>\n *\n * @param {*} source The source that will be used to make a copy.\n *                   Can be any type, including primitives, `null`, and `undefined`.\n * @param {(Object|Array)=} destination Destination into which the source is copied. If\n *     provided, must be of the same type as `source`.\n * @returns {*} The copy or updated `destination`, if `destination` was specified.\n *\n * @example\n  <example module=\"copyExample\" name=\"angular-copy\">\n    <file name=\"index.html\">\n      <div ng-controller=\"ExampleController\">\n        <form novalidate class=\"simple-form\">\n          <label>Name: <input type=\"text\" ng-model=\"user.name\" /></label><br />\n          <label>Age:  <input type=\"number\" ng-model=\"user.age\" /></label><br />\n          Gender: <label><input type=\"radio\" ng-model=\"user.gender\" value=\"male\" />male</label>\n                  <label><input type=\"radio\" ng-model=\"user.gender\" value=\"female\" />female</label><br />\n          <button ng-click=\"reset()\">RESET</button>\n          <button ng-click=\"update(user)\">SAVE</button>\n        </form>\n        <pre>form = {{user | json}}</pre>\n        <pre>master = {{master | json}}</pre>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      // Module: copyExample\n      angular.\n        module('copyExample', []).\n        controller('ExampleController', ['$scope', function($scope) {\n          $scope.master = {};\n\n          $scope.reset = function() {\n            // Example with 1 argument\n            $scope.user = angular.copy($scope.master);\n          };\n\n          $scope.update = function(user) {\n            // Example with 2 arguments\n            angular.copy(user, $scope.master);\n          };\n\n          $scope.reset();\n        }]);\n    </file>\n  </example>\n */\nfunction copy(source, destination) {\n\tvar stackSource = [];\n\tvar stackDest = [];\n\n\tif (destination) {\n\t\tif (isTypedArray(destination) || isArrayBuffer(destination)) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpta\",\n\t\t\t\t\"Can't copy! TypedArray destination cannot be mutated.\"\n\t\t\t);\n\t\t}\n\t\tif (source === destination) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpi\",\n\t\t\t\t\"Can't copy! Source and destination are identical.\"\n\t\t\t);\n\t\t}\n\n\t\t// Empty the destination object\n\t\tif (isArray(destination)) {\n\t\t\tdestination.length = 0;\n\t\t} else {\n\t\t\tforEach(destination, function (value, key) {\n\t\t\t\tif (key !== \"$$hashKey\") {\n\t\t\t\t\tdelete destination[key];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tstackSource.push(source);\n\t\tstackDest.push(destination);\n\t\treturn copyRecurse(source, destination);\n\t}\n\n\treturn copyElement(source);\n\n\tfunction copyRecurse(source, destination) {\n\t\tvar h = destination.$$hashKey;\n\t\tvar key;\n\t\tif (isArray(source)) {\n\t\t\tfor (var i = 0, ii = source.length; i < ii; i++) {\n\t\t\t\tdestination.push(copyElement(source[i]));\n\t\t\t}\n\t\t} else if (isBlankObject(source)) {\n\t\t\t// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (key in source) {\n\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t}\n\t\t} else if (source && typeof source.hasOwnProperty === \"function\") {\n\t\t\t// Slow path, which must rely on hasOwnProperty\n\t\t\tfor (key in source) {\n\t\t\t\tif (source.hasOwnProperty(key)) {\n\t\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Slowest path --- hasOwnProperty can't be called as a method\n\t\t\tfor (key in source) {\n\t\t\t\tif (hasOwnProperty.call(source, key)) {\n\t\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetHashKey(destination, h);\n\t\treturn destination;\n\t}\n\n\tfunction copyElement(source) {\n\t\t// Simple values\n\t\tif (!isObject(source)) {\n\t\t\treturn source;\n\t\t}\n\n\t\t// Already copied values\n\t\tvar index = stackSource.indexOf(source);\n\t\tif (index !== -1) {\n\t\t\treturn stackDest[index];\n\t\t}\n\n\t\tif (isWindow(source) || isScope(source)) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpws\",\n\t\t\t\t\"Can't copy! Making copies of Window or Scope instances is not supported.\"\n\t\t\t);\n\t\t}\n\n\t\tvar needsRecurse = false;\n\t\tvar destination = copyType(source);\n\n\t\tif (destination === undefined) {\n\t\t\tdestination = isArray(source)\n\t\t\t\t? []\n\t\t\t\t: Object.create(getPrototypeOf(source));\n\t\t\tneedsRecurse = true;\n\t\t}\n\n\t\tstackSource.push(source);\n\t\tstackDest.push(destination);\n\n\t\treturn needsRecurse ? copyRecurse(source, destination) : destination;\n\t}\n\n\tfunction copyType(source) {\n\t\tswitch (toString.call(source)) {\n\t\t\tcase \"[object Int8Array]\":\n\t\t\tcase \"[object Int16Array]\":\n\t\t\tcase \"[object Int32Array]\":\n\t\t\tcase \"[object Float32Array]\":\n\t\t\tcase \"[object Float64Array]\":\n\t\t\tcase \"[object Uint8Array]\":\n\t\t\tcase \"[object Uint8ClampedArray]\":\n\t\t\tcase \"[object Uint16Array]\":\n\t\t\tcase \"[object Uint32Array]\":\n\t\t\t\treturn new source.constructor(\n\t\t\t\t\tcopyElement(source.buffer),\n\t\t\t\t\tsource.byteOffset,\n\t\t\t\t\tsource.length\n\t\t\t\t);\n\n\t\t\tcase \"[object ArrayBuffer]\":\n\t\t\t\t// Support: IE10\n\t\t\t\tif (!source.slice) {\n\t\t\t\t\t// If we're in this case we know the environment supports ArrayBuffer\n\n\t\t\t\t\tvar copied = new ArrayBuffer(source.byteLength);\n\t\t\t\t\tnew Uint8Array(copied).set(new Uint8Array(source));\n\n\t\t\t\t\treturn copied;\n\t\t\t\t}\n\t\t\t\treturn source.slice(0);\n\n\t\t\tcase \"[object Boolean]\":\n\t\t\tcase \"[object Number]\":\n\t\t\tcase \"[object String]\":\n\t\t\tcase \"[object Date]\":\n\t\t\t\treturn new source.constructor(source.valueOf());\n\n\t\t\tcase \"[object RegExp]\":\n\t\t\t\tvar re = new RegExp(\n\t\t\t\t\tsource.source,\n\t\t\t\t\tsource.toString().match(/[^\\/]*$/)[0]\n\t\t\t\t);\n\t\t\t\tre.lastIndex = source.lastIndex;\n\t\t\t\treturn re;\n\n\t\t\tcase \"[object Blob]\":\n\t\t\t\treturn new source.constructor([source], { type: source.type });\n\t\t}\n\n\t\tif (isFunction(source.cloneNode)) {\n\t\t\treturn source.cloneNode(true);\n\t\t}\n\t}\n}\n\n/**\n * @ngdoc function\n * @name angular.bind\n * @module ng\n * @kind function\n *\n * @description\n * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\n * `fn`). You can supply optional `args` that are prebound to the function. This feature is also\n * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as\n * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).\n *\n * @param {Object} self Context which `fn` should be evaluated in.\n * @param {function()} fn Function to be bound.\n * @param {...*} args Optional arguments to be prebound to the `fn` function call.\n * @returns {function()} Function that wraps the `fn` with all the specified bindings.\n */\n\nfunction toJsonReplacer(key, value) {\n\tvar val = value;\n\n\tif (\n\t\ttypeof key === \"string\" &&\n\t\tkey.charAt(0) === \"$\" &&\n\t\tkey.charAt(1) === \"$\"\n\t) {\n\t\tval = undefined;\n\t} else if (isWindow(value)) {\n\t\tval = \"$WINDOW\";\n\t} else if (value && window.document === value) {\n\t\tval = \"$DOCUMENT\";\n\t} else if (isScope(value)) {\n\t\tval = \"$SCOPE\";\n\t}\n\n\treturn val;\n}\n\n/**\n * Creates a new object without a prototype. This object is useful for lookup without having to\n * guard against prototypically inherited properties via hasOwnProperty.\n *\n * Related micro-benchmarks:\n * - http://jsperf.com/object-create2\n * - http://jsperf.com/proto-map-lookup/2\n * - http://jsperf.com/for-in-vs-object-keys2\n *\n * @returns {Object}\n */\nfunction createMap() {\n\treturn Object.create(null);\n}\n\nfunction serializeObject(obj) {\n\tvar seen = [];\n\n\treturn JSON.stringify(obj, function (key, val) {\n\t\tval = toJsonReplacer(key, val);\n\t\tif (isObject(val)) {\n\t\t\tif (seen.indexOf(val) >= 0) {\n\t\t\t\treturn \"...\";\n\t\t\t}\n\n\t\t\tseen.push(val);\n\t\t}\n\t\treturn val;\n\t});\n}\n\nfunction toDebugString(obj) {\n\tif (typeof obj === \"function\") {\n\t\treturn obj.toString().replace(/ \\{[\\s\\S]*$/, \"\");\n\t} else if (isUndefined(obj)) {\n\t\treturn \"undefined\";\n\t} else if (typeof obj !== \"string\") {\n\t\treturn serializeObject(obj);\n\t}\n\treturn obj;\n}\n\n/**\n * @description\n *\n * This object provides a utility for producing rich Error messages within\n * Angular. It can be called as follows:\n *\n * var exampleMinErr = minErr('example');\n * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);\n *\n * The above creates an instance of minErr in the example namespace. The\n * resulting error will have a namespaced error code of example.one.  The\n * resulting error will replace {0} with the value of foo, and {1} with the\n * value of bar. The object is not restricted in the number of arguments it can\n * take.\n *\n * If fewer arguments are specified than necessary for interpolation, the extra\n * interpolation markers will be preserved in the final string.\n *\n * Since data will be parsed statically during a build step, some restrictions\n * are applied with respect to how minErr instances are created and called.\n * Instances should have names of the form namespaceMinErr for a minErr created\n * using minErr('namespace') . Error codes, namespaces and template strings\n * should all be static strings, not variables or general expressions.\n *\n * @param {string} module The namespace to use for the new minErr instance.\n * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning\n *   error from returned function, for cases when a particular type of error is useful.\n * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance\n */\n\nfunction minErr(module, ErrorConstructor) {\n\tErrorConstructor = ErrorConstructor || Error;\n\treturn function () {\n\t\tvar SKIP_INDEXES = 2;\n\n\t\tvar templateArgs = arguments,\n\t\t\tcode = templateArgs[0],\n\t\t\tmessage = \"[\" + (module ? module + \":\" : \"\") + code + \"] \",\n\t\t\ttemplate = templateArgs[1],\n\t\t\tparamPrefix,\n\t\t\ti;\n\n\t\tmessage += template.replace(/\\{\\d+\\}/g, function (match) {\n\t\t\tvar index = +match.slice(1, -1),\n\t\t\t\tshiftedIndex = index + SKIP_INDEXES;\n\n\t\t\tif (shiftedIndex < templateArgs.length) {\n\t\t\t\treturn toDebugString(templateArgs[shiftedIndex]);\n\t\t\t}\n\n\t\t\treturn match;\n\t\t});\n\n\t\tmessage +=\n\t\t\t'\\nhttp://errors.angularjs.org/\"NG_VERSION_FULL\"/' +\n\t\t\t(module ? module + \"/\" : \"\") +\n\t\t\tcode;\n\n\t\tfor (\n\t\t\ti = SKIP_INDEXES, paramPrefix = \"?\";\n\t\t\ti < templateArgs.length;\n\t\t\ti++, paramPrefix = \"&\"\n\t\t) {\n\t\t\tmessage +=\n\t\t\t\tparamPrefix +\n\t\t\t\t\"p\" +\n\t\t\t\t(i - SKIP_INDEXES) +\n\t\t\t\t\"=\" +\n\t\t\t\tencodeURIComponent(toDebugString(templateArgs[i]));\n\t\t}\n\n\t\treturn new ErrorConstructor(message);\n\t};\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $parseMinErr = minErr(\"$parse\");\n\n// Sandboxing Angular Expressions\n// ------------------------------\n// Angular expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by\n// various means such as obtaining a reference to native JS functions like the Function constructor.\n//\n// As an example, consider the following Angular expression:\n//\n//   {}.toString.constructor('alert(\"evil JS code\")')\n//\n// It is important to realize that if you create an expression from a string that contains user provided\n// content then it is possible that your application contains a security vulnerability to an XSS style attack.\n//\n// See https://docs.angularjs.org/guide/security\n\nfunction getStringValue(name) {\n\t// Property names must be strings. This means that non-string objects cannot be used\n\t// as keys in an object. Any non-string object, including a number, is typecasted\n\t// into a string via the toString method.\n\t// -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names\n\t//\n\t// So, to ensure that we are checking the same `name` that JavaScript would use, we cast it\n\t// to a string. It's not always possible. If `name` is an object and its `toString` method is\n\t// 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:\n\t//\n\t// TypeError: Cannot convert object to primitive value\n\t//\n\t// For performance reasons, we don't catch this error here and allow it to propagate up the call\n\t// stack. Note that you'll get the same error in JavaScript if you try to access a property using\n\t// such a 'broken' object as a key.\n\treturn name + \"\";\n}\n\nvar OPERATORS = createMap();\nforEach(\n\t\"+ - * / % === !== == != < > <= >= && || ! = |\".split(\" \"),\n\tfunction (operator) {\n\t\tOPERATORS[operator] = true;\n\t}\n);\nvar ESCAPE = {\n\tn: \"\\n\",\n\tf: \"\\f\",\n\tr: \"\\r\",\n\tt: \"\\t\",\n\tv: \"\\v\",\n\t\"'\": \"'\",\n\t'\"': '\"',\n};\n\n/////////////////////////////////////////\n\n/**\n * @constructor\n */\nfunction Lexer(options) {\n\tthis.options = options || {};\n}\n\nLexer.prototype = {\n\tconstructor: Lexer,\n\n\tlex: function (text) {\n\t\tthis.text = text;\n\t\tthis.index = 0;\n\t\tthis.tokens = [];\n\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.text.charAt(this.index);\n\t\t\tif (ch === '\"' || ch === \"'\" || ch === \"`\") {\n\t\t\t\tthis.readString(ch);\n\t\t\t} else if (\n\t\t\t\tthis.isNumber(ch) ||\n\t\t\t\t(ch === \".\" && this.isNumber(this.peek()))\n\t\t\t) {\n\t\t\t\tthis.readNumber();\n\t\t\t} else if (this.isIdentifierStart(this.peekMultichar())) {\n\t\t\t\tthis.readIdent();\n\t\t\t} else if (this.is(ch, \"(){}[].,;:?\")) {\n\t\t\t\tthis.tokens.push({ index: this.index, text: ch });\n\t\t\t\tthis.index++;\n\t\t\t} else if (this.isWhitespace(ch)) {\n\t\t\t\tthis.index++;\n\t\t\t} else {\n\t\t\t\tvar ch2 = ch + this.peek();\n\t\t\t\tvar ch3 = ch2 + this.peek(2);\n\t\t\t\tvar op1 = OPERATORS[ch];\n\t\t\t\tvar op2 = OPERATORS[ch2];\n\t\t\t\tvar op3 = OPERATORS[ch3];\n\t\t\t\tif (op1 || op2 || op3) {\n\t\t\t\t\tvar token = op3 ? ch3 : op2 ? ch2 : ch;\n\t\t\t\t\tthis.tokens.push({ index: this.index, text: token, operator: true });\n\t\t\t\t\tthis.index += token.length;\n\t\t\t\t} else {\n\t\t\t\t\tthis.throwError(\n\t\t\t\t\t\t\"Unexpected next character \",\n\t\t\t\t\t\tthis.index,\n\t\t\t\t\t\tthis.index + 1\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.tokens;\n\t},\n\n\tis: function (ch, chars) {\n\t\treturn chars.indexOf(ch) !== -1;\n\t},\n\n\tpeek: function (i) {\n\t\tvar num = i || 1;\n\t\treturn this.index + num < this.text.length\n\t\t\t? this.text.charAt(this.index + num)\n\t\t\t: false;\n\t},\n\n\tisNumber: function (ch) {\n\t\treturn ch >= \"0\" && ch <= \"9\" && typeof ch === \"string\";\n\t},\n\n\tisWhitespace: function (ch) {\n\t\t// IE treats non-breaking space as \\u00A0\n\t\treturn (\n\t\t\tch === \" \" ||\n\t\t\tch === \"\\r\" ||\n\t\t\tch === \"\\t\" ||\n\t\t\tch === \"\\n\" ||\n\t\t\tch === \"\\v\" ||\n\t\t\tch === \"\\u00A0\"\n\t\t);\n\t},\n\n\tisIdentifierStart: function (ch) {\n\t\treturn this.options.isIdentifierStart\n\t\t\t? this.options.isIdentifierStart(ch, this.codePointAt(ch))\n\t\t\t: this.isValidIdentifierStart(ch);\n\t},\n\n\tisValidIdentifierStart: function (ch) {\n\t\treturn (\n\t\t\t(ch >= \"a\" && ch <= \"z\") ||\n\t\t\t(ch >= \"A\" && ch <= \"Z\") ||\n\t\t\tch === \"_\" ||\n\t\t\tch === \"$\"\n\t\t);\n\t},\n\n\tisIdentifierContinue: function (ch) {\n\t\treturn this.options.isIdentifierContinue\n\t\t\t? this.options.isIdentifierContinue(ch, this.codePointAt(ch))\n\t\t\t: this.isValidIdentifierContinue(ch);\n\t},\n\n\tisValidIdentifierContinue: function (ch, cp) {\n\t\treturn this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);\n\t},\n\n\tcodePointAt: function (ch) {\n\t\tif (ch.length === 1) {\n\t\t\treturn ch.charCodeAt(0);\n\t\t}\n\n\t\treturn (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35fdc00;\n\t},\n\n\tpeekMultichar: function () {\n\t\tvar ch = this.text.charAt(this.index);\n\t\tvar peek = this.peek();\n\t\tif (!peek) {\n\t\t\treturn ch;\n\t\t}\n\t\tvar cp1 = ch.charCodeAt(0);\n\t\tvar cp2 = peek.charCodeAt(0);\n\t\tif (cp1 >= 0xd800 && cp1 <= 0xdbff && cp2 >= 0xdc00 && cp2 <= 0xdfff) {\n\t\t\treturn ch + peek;\n\t\t}\n\t\treturn ch;\n\t},\n\n\tisExpOperator: function (ch) {\n\t\treturn ch === \"-\" || ch === \"+\" || this.isNumber(ch);\n\t},\n\n\tthrowError: function (error, start, end) {\n\t\tend = end || this.index;\n\t\tvar colStr = isDefined(start)\n\t\t\t? \"s \" +\n\t\t\t\tstart +\n\t\t\t\t\"-\" +\n\t\t\t\tthis.index +\n\t\t\t\t\" [\" +\n\t\t\t\tthis.text.substring(start, end) +\n\t\t\t\t\"]\"\n\t\t\t: \" \" + end;\n\t\tthrow $parseMinErr(\n\t\t\t\"lexerr\",\n\t\t\t\"Lexer Error: {0} at column{1} in expression [{2}].\",\n\t\t\terror,\n\t\t\tcolStr,\n\t\t\tthis.text\n\t\t);\n\t},\n\n\treadNumber: function () {\n\t\tvar number = \"\";\n\t\tvar start = this.index;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = lowercase(this.text.charAt(this.index));\n\t\t\tif (ch === \".\" || this.isNumber(ch)) {\n\t\t\t\tnumber += ch;\n\t\t\t} else {\n\t\t\t\tvar peekCh = this.peek();\n\t\t\t\tif (ch === \"e\" && this.isExpOperator(peekCh)) {\n\t\t\t\t\tnumber += ch;\n\t\t\t\t} else if (\n\t\t\t\t\tthis.isExpOperator(ch) &&\n\t\t\t\t\tpeekCh &&\n\t\t\t\t\tthis.isNumber(peekCh) &&\n\t\t\t\t\tnumber.charAt(number.length - 1) === \"e\"\n\t\t\t\t) {\n\t\t\t\t\tnumber += ch;\n\t\t\t\t} else if (\n\t\t\t\t\tthis.isExpOperator(ch) &&\n\t\t\t\t\t(!peekCh || !this.isNumber(peekCh)) &&\n\t\t\t\t\tnumber.charAt(number.length - 1) === \"e\"\n\t\t\t\t) {\n\t\t\t\t\tthis.throwError(\"Invalid exponent\");\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.index++;\n\t\t}\n\t\tthis.tokens.push({\n\t\t\tindex: start,\n\t\t\ttext: number,\n\t\t\tconstant: true,\n\t\t\tvalue: Number(number),\n\t\t});\n\t},\n\n\treadIdent: function () {\n\t\tvar start = this.index;\n\t\tthis.index += this.peekMultichar().length;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.peekMultichar();\n\t\t\tif (!this.isIdentifierContinue(ch)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.index += ch.length;\n\t\t}\n\t\tthis.tokens.push({\n\t\t\tindex: start,\n\t\t\ttext: this.text.slice(start, this.index),\n\t\t\tidentifier: true,\n\t\t});\n\t},\n\n\treadString: function (quote) {\n\t\t// quote will be ', \" or `\n\t\tvar start = this.index;\n\t\tthis.index++;\n\t\tvar string = \"\";\n\t\tvar rawString = quote;\n\t\tvar isTemplateLiteral = quote === \"`\";\n\t\tvar escape = false;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.text.charAt(this.index);\n\t\t\tif (\n\t\t\t\tisTemplateLiteral &&\n\t\t\t\tch === \"$\" &&\n\t\t\t\tthis.text.charAt(this.index + 1) === \"{\"\n\t\t\t) {\n\t\t\t\tthis.tokens.push({\n\t\t\t\t\tindex: start,\n\t\t\t\t\ttext: rawString,\n\t\t\t\t\tconstant: true,\n\t\t\t\t\tvalue: string,\n\t\t\t\t});\n\t\t\t\tvar inside = this.text.indexOf(\"}\", this.index);\n\t\t\t\tvar myVariable = this.text.substr(\n\t\t\t\t\tthis.index + 2,\n\t\t\t\t\tinside - this.index - 2\n\t\t\t\t);\n\t\t\t\tthis.tokens.push({ index: this.index, text: \"+\", operator: true });\n\t\t\t\tvar lexed = new Lexer(this.options).lex(myVariable);\n\t\t\t\tfor (var i = 0, len = lexed.length; i < len; i++) {\n\t\t\t\t\tthis.tokens.push(lexed[i]);\n\t\t\t\t}\n\t\t\t\tthis.tokens.push({ index: this.index, text: \"+\", operator: true });\n\t\t\t\tthis.index = inside;\n\t\t\t\tthis.readString(\"`\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trawString += ch;\n\t\t\tif (escape) {\n\t\t\t\tif (ch === \"u\") {\n\t\t\t\t\tvar hex = this.text.substring(this.index + 1, this.index + 5);\n\t\t\t\t\tif (!hex.match(/[\\da-f]{4}/i)) {\n\t\t\t\t\t\tthis.throwError(\"Invalid unicode escape [\\\\u\" + hex + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.index += 4;\n\t\t\t\t\tstring += String.fromCharCode(parseInt(hex, 16));\n\t\t\t\t} else {\n\t\t\t\t\tvar rep = ESCAPE[ch];\n\t\t\t\t\tstring = string + (rep || ch);\n\t\t\t\t}\n\t\t\t\tescape = false;\n\t\t\t} else if (ch === \"\\\\\") {\n\t\t\t\tescape = true;\n\t\t\t} else if (ch === quote) {\n\t\t\t\t// Matching closing quote\n\t\t\t\tthis.index++;\n\t\t\t\tthis.tokens.push({\n\t\t\t\t\tindex: start,\n\t\t\t\t\ttext: rawString,\n\t\t\t\t\tconstant: true,\n\t\t\t\t\tvalue: string,\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tstring += ch;\n\t\t\t}\n\t\t\tthis.index++;\n\t\t}\n\t\tthis.throwError(\"Unterminated quote\", start);\n\t},\n};\n\nfunction AST(lexer, options) {\n\tthis.lexer = lexer;\n\tthis.options = options;\n}\n\nAST.Program = \"Program\";\nAST.ExpressionStatement = \"ExpressionStatement\";\nAST.AssignmentExpression = \"AssignmentExpression\";\nAST.ConditionalExpression = \"ConditionalExpression\";\nAST.LogicalExpression = \"LogicalExpression\";\nAST.BinaryExpression = \"BinaryExpression\";\nAST.UnaryExpression = \"UnaryExpression\";\nAST.CallExpression = \"CallExpression\";\nAST.MemberExpression = \"MemberExpression\";\nAST.Identifier = \"Identifier\";\nAST.Literal = \"Literal\";\nAST.ArrayExpression = \"ArrayExpression\";\nAST.Property = \"Property\";\nAST.ObjectExpression = \"ObjectExpression\";\nAST.ThisExpression = \"ThisExpression\";\nAST.LocalsExpression = \"LocalsExpression\";\n\n// Internal use only\nAST.NGValueParameter = \"NGValueParameter\";\n\nAST.prototype = {\n\tast: function (text) {\n\t\tthis.text = text;\n\t\tthis.tokens = this.lexer.lex(text);\n\n\t\tvar value = this.program();\n\n\t\tif (this.tokens.length !== 0) {\n\t\t\tthis.throwError(\"is an unexpected token\", this.tokens[0]);\n\t\t}\n\n\t\treturn value;\n\t},\n\n\tprogram: function () {\n\t\tvar body = [];\n\t\twhile (true) {\n\t\t\tif (this.tokens.length > 0 && !this.peek(\"}\", \")\", \";\", \"]\")) {\n\t\t\t\tbody.push(this.expressionStatement());\n\t\t\t}\n\t\t\tif (!this.expect(\";\")) {\n\t\t\t\treturn { type: AST.Program, body: body };\n\t\t\t}\n\t\t}\n\t},\n\n\texpressionStatement: function () {\n\t\treturn { type: AST.ExpressionStatement, expression: this.filterChain() };\n\t},\n\n\tfilterChain: function () {\n\t\tvar left = this.expression();\n\t\twhile (this.expect(\"|\")) {\n\t\t\tleft = this.filter(left);\n\t\t}\n\t\treturn left;\n\t},\n\n\texpression: function () {\n\t\treturn this.assignment();\n\t},\n\n\tassignment: function () {\n\t\tvar result = this.ternary();\n\t\tif (this.expect(\"=\")) {\n\t\t\tif (!isAssignable(result)) {\n\t\t\t\tthrow $parseMinErr(\"lval\", \"Trying to assign a value to a non l-value\");\n\t\t\t}\n\n\t\t\tresult = {\n\t\t\t\ttype: AST.AssignmentExpression,\n\t\t\t\tleft: result,\n\t\t\t\tright: this.assignment(),\n\t\t\t\toperator: \"=\",\n\t\t\t};\n\t\t}\n\t\treturn result;\n\t},\n\n\tternary: function () {\n\t\tvar test = this.logicalOR();\n\t\tvar alternate;\n\t\tvar consequent;\n\t\tif (this.expect(\"?\")) {\n\t\t\talternate = this.expression();\n\t\t\tif (this.consume(\":\")) {\n\t\t\t\tconsequent = this.expression();\n\t\t\t\treturn {\n\t\t\t\t\ttype: AST.ConditionalExpression,\n\t\t\t\t\ttest: test,\n\t\t\t\t\talternate: alternate,\n\t\t\t\t\tconsequent: consequent,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn test;\n\t},\n\n\tlogicalOR: function () {\n\t\tvar left = this.logicalAND();\n\t\twhile (this.expect(\"||\")) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.LogicalExpression,\n\t\t\t\toperator: \"||\",\n\t\t\t\tleft: left,\n\t\t\t\tright: this.logicalAND(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tlogicalAND: function () {\n\t\tvar left = this.equality();\n\t\twhile (this.expect(\"&&\")) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.LogicalExpression,\n\t\t\t\toperator: \"&&\",\n\t\t\t\tleft: left,\n\t\t\t\tright: this.equality(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tequality: function () {\n\t\tvar left = this.relational();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"==\", \"!=\", \"===\", \"!==\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.relational(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\trelational: function () {\n\t\tvar left = this.additive();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"<\", \">\", \"<=\", \">=\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.additive(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tadditive: function () {\n\t\tvar left = this.multiplicative();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"+\", \"-\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.multiplicative(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tmultiplicative: function () {\n\t\tvar left = this.unary();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"*\", \"/\", \"%\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.unary(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tunary: function () {\n\t\tvar token;\n\t\tif ((token = this.expect(\"+\", \"-\", \"!\"))) {\n\t\t\treturn {\n\t\t\t\ttype: AST.UnaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tprefix: true,\n\t\t\t\targument: this.unary(),\n\t\t\t};\n\t\t}\n\t\treturn this.primary();\n\t},\n\n\tprimary: function () {\n\t\tvar primary;\n\t\tif (this.expect(\"(\")) {\n\t\t\tprimary = this.filterChain();\n\t\t\tthis.consume(\")\");\n\t\t} else if (this.expect(\"[\")) {\n\t\t\tprimary = this.arrayDeclaration();\n\t\t} else if (this.expect(\"{\")) {\n\t\t\tprimary = this.object();\n\t\t} else if (this.selfReferential.hasOwnProperty(this.peek().text)) {\n\t\t\tprimary = copy(this.selfReferential[this.consume().text]);\n\t\t} else if (this.options.literals.hasOwnProperty(this.peek().text)) {\n\t\t\tprimary = {\n\t\t\t\ttype: AST.Literal,\n\t\t\t\tvalue: this.options.literals[this.consume().text],\n\t\t\t};\n\t\t} else if (this.peek().identifier) {\n\t\t\tprimary = this.identifier();\n\t\t} else if (this.peek().constant) {\n\t\t\tprimary = this.constant();\n\t\t} else {\n\t\t\tthis.throwError(\"not a primary expression\", this.peek());\n\t\t}\n\n\t\tvar next;\n\t\twhile ((next = this.expect(\"(\", \"[\", \".\"))) {\n\t\t\tif (next.text === \"(\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.CallExpression,\n\t\t\t\t\tcallee: primary,\n\t\t\t\t\targuments: this.parseArguments(),\n\t\t\t\t};\n\t\t\t\tthis.consume(\")\");\n\t\t\t} else if (next.text === \"[\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.MemberExpression,\n\t\t\t\t\tobject: primary,\n\t\t\t\t\tproperty: this.expression(),\n\t\t\t\t\tcomputed: true,\n\t\t\t\t};\n\t\t\t\tthis.consume(\"]\");\n\t\t\t} else if (next.text === \".\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.MemberExpression,\n\t\t\t\t\tobject: primary,\n\t\t\t\t\tproperty: this.identifier(),\n\t\t\t\t\tcomputed: false,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.throwError(\"IMPOSSIBLE\");\n\t\t\t}\n\t\t}\n\t\treturn primary;\n\t},\n\n\tfilter: function (baseExpression) {\n\t\tvar args = [baseExpression];\n\t\tvar result = {\n\t\t\ttype: AST.CallExpression,\n\t\t\tcallee: this.identifier(),\n\t\t\targuments: args,\n\t\t\tfilter: true,\n\t\t};\n\n\t\twhile (this.expect(\":\")) {\n\t\t\targs.push(this.expression());\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tparseArguments: function () {\n\t\tvar args = [];\n\t\tif (this.peekToken().text !== \")\") {\n\t\t\tdo {\n\t\t\t\targs.push(this.filterChain());\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\treturn args;\n\t},\n\n\tidentifier: function () {\n\t\tvar token = this.consume();\n\t\tif (!token.identifier) {\n\t\t\tthis.throwError(\"is not a valid identifier\", token);\n\t\t}\n\t\treturn { type: AST.Identifier, name: token.text };\n\t},\n\n\tconstant: function () {\n\t\t// TODO check that it is a constant\n\t\treturn { type: AST.Literal, value: this.consume().value };\n\t},\n\n\tarrayDeclaration: function () {\n\t\tvar elements = [];\n\t\tif (this.peekToken().text !== \"]\") {\n\t\t\tdo {\n\t\t\t\tif (this.peek(\"]\")) {\n\t\t\t\t\t// Support trailing commas per ES5.1.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telements.push(this.expression());\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\tthis.consume(\"]\");\n\n\t\treturn { type: AST.ArrayExpression, elements: elements };\n\t},\n\n\tobject: function () {\n\t\tvar properties = [],\n\t\t\tproperty;\n\t\tif (this.peekToken().text !== \"}\") {\n\t\t\tdo {\n\t\t\t\tif (this.peek(\"}\")) {\n\t\t\t\t\t// Support trailing commas per ES5.1.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tproperty = { type: AST.Property, kind: \"init\" };\n\t\t\t\tif (this.peek().constant) {\n\t\t\t\t\tproperty.key = this.constant();\n\t\t\t\t\tproperty.computed = false;\n\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t} else if (this.peek().identifier) {\n\t\t\t\t\tproperty.key = this.identifier();\n\t\t\t\t\tproperty.computed = false;\n\t\t\t\t\tif (this.peek(\":\")) {\n\t\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproperty.value = property.key;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.peek(\"[\")) {\n\t\t\t\t\tthis.consume(\"[\");\n\t\t\t\t\tproperty.key = this.expression();\n\t\t\t\t\tthis.consume(\"]\");\n\t\t\t\t\tproperty.computed = true;\n\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t} else {\n\t\t\t\t\tthis.throwError(\"invalid key\", this.peek());\n\t\t\t\t}\n\t\t\t\tproperties.push(property);\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\tthis.consume(\"}\");\n\n\t\treturn { type: AST.ObjectExpression, properties: properties };\n\t},\n\n\tthrowError: function (msg, token) {\n\t\tthrow $parseMinErr(\n\t\t\t\"syntax\",\n\t\t\t\"Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].\",\n\t\t\ttoken.text,\n\t\t\tmsg,\n\t\t\ttoken.index + 1,\n\t\t\tthis.text,\n\t\t\tthis.text.substring(token.index)\n\t\t);\n\t},\n\n\tconsume: function (e1) {\n\t\tif (this.tokens.length === 0) {\n\t\t\tthrow $parseMinErr(\n\t\t\t\t\"ueoe\",\n\t\t\t\t\"Unexpected end of expression: {0}\",\n\t\t\t\tthis.text\n\t\t\t);\n\t\t}\n\n\t\tvar token = this.expect(e1);\n\t\tif (!token) {\n\t\t\tthis.throwError(\"is unexpected, expecting [\" + e1 + \"]\", this.peek());\n\t\t}\n\t\treturn token;\n\t},\n\n\tpeekToken: function () {\n\t\tif (this.tokens.length === 0) {\n\t\t\tthrow $parseMinErr(\n\t\t\t\t\"ueoe\",\n\t\t\t\t\"Unexpected end of expression: {0}\",\n\t\t\t\tthis.text\n\t\t\t);\n\t\t}\n\t\treturn this.tokens[0];\n\t},\n\n\tpeek: function (e1, e2, e3, e4) {\n\t\treturn this.peekAhead(0, e1, e2, e3, e4);\n\t},\n\n\tpeekAhead: function (i, e1, e2, e3, e4) {\n\t\tif (this.tokens.length > i) {\n\t\t\tvar token = this.tokens[i];\n\t\t\tvar t = token.text;\n\t\t\tif (\n\t\t\t\tt === e1 ||\n\t\t\t\tt === e2 ||\n\t\t\t\tt === e3 ||\n\t\t\t\tt === e4 ||\n\t\t\t\t(!e1 && !e2 && !e3 && !e4)\n\t\t\t) {\n\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\texpect: function (e1, e2, e3, e4) {\n\t\tvar token = this.peek(e1, e2, e3, e4);\n\t\tif (token) {\n\t\t\tthis.tokens.shift();\n\t\t\treturn token;\n\t\t}\n\t\treturn false;\n\t},\n};\n\nfunction ifDefined(v, d) {\n\treturn typeof v !== \"undefined\" ? v : d;\n}\n\nfunction plusFn(l, r) {\n\tif (typeof l === \"undefined\") {\n\t\treturn r;\n\t}\n\tif (typeof r === \"undefined\") {\n\t\treturn l;\n\t}\n\treturn l + r;\n}\n\nfunction isStateless($filter, filterName) {\n\tvar fn = $filter(filterName);\n\tif (!fn) {\n\t\tthrow new Error(\"Filter '\" + filterName + \"' is not defined\");\n\t}\n\treturn !fn.$stateful;\n}\n\nfunction findConstantAndWatchExpressions(ast, $filter) {\n\tvar allConstants;\n\tvar argsToWatch;\n\tvar isStatelessFilter;\n\tswitch (ast.type) {\n\t\tcase AST.Program:\n\t\t\tallConstants = true;\n\t\t\tforEach(ast.body, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr.expression, $filter);\n\t\t\t\tallConstants = allConstants && expr.expression.constant;\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tbreak;\n\t\tcase AST.Literal:\n\t\t\tast.constant = true;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t\tcase AST.UnaryExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.argument, $filter);\n\t\t\tast.constant = ast.argument.constant;\n\t\t\tast.toWatch = ast.argument.toWatch;\n\t\t\tbreak;\n\t\tcase AST.BinaryExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);\n\t\t\tbreak;\n\t\tcase AST.LogicalExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = ast.constant ? [] : [ast];\n\t\t\tbreak;\n\t\tcase AST.ConditionalExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.test, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.alternate, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.consequent, $filter);\n\t\t\tast.constant =\n\t\t\t\tast.test.constant && ast.alternate.constant && ast.consequent.constant;\n\t\t\tast.toWatch = ast.constant ? [] : [ast];\n\t\t\tbreak;\n\t\tcase AST.Identifier:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.MemberExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.object, $filter);\n\t\t\tif (ast.computed) {\n\t\t\t\tfindConstantAndWatchExpressions(ast.property, $filter);\n\t\t\t}\n\t\t\tast.constant =\n\t\t\t\tast.object.constant && (!ast.computed || ast.property.constant);\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.CallExpression:\n\t\t\tisStatelessFilter = ast.filter\n\t\t\t\t? isStateless($filter, ast.callee.name)\n\t\t\t\t: false;\n\t\t\tallConstants = isStatelessFilter;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr, $filter);\n\t\t\t\tallConstants = allConstants && expr.constant;\n\t\t\t\tif (!expr.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, expr.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = isStatelessFilter ? argsToWatch : [ast];\n\t\t\tbreak;\n\t\tcase AST.AssignmentExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.ArrayExpression:\n\t\t\tallConstants = true;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr, $filter);\n\t\t\t\tallConstants = allConstants && expr.constant;\n\t\t\t\tif (!expr.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, expr.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = argsToWatch;\n\t\t\tbreak;\n\t\tcase AST.ObjectExpression:\n\t\t\tallConstants = true;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\tfindConstantAndWatchExpressions(property.value, $filter);\n\t\t\t\tallConstants =\n\t\t\t\t\tallConstants && property.value.constant && !property.computed;\n\t\t\t\tif (!property.value.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, property.value.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = argsToWatch;\n\t\t\tbreak;\n\t\tcase AST.ThisExpression:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t\tcase AST.LocalsExpression:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t}\n}\n\nfunction getInputs(body) {\n\tif (body.length !== 1) {\n\t\treturn;\n\t}\n\tvar lastExpression = body[0].expression;\n\tvar candidate = lastExpression.toWatch;\n\tif (candidate.length !== 1) {\n\t\treturn candidate;\n\t}\n\treturn candidate[0] !== lastExpression ? candidate : undefined;\n}\n\nfunction isAssignable(ast) {\n\treturn ast.type === AST.Identifier || ast.type === AST.MemberExpression;\n}\n\nfunction assignableAST(ast) {\n\tif (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {\n\t\treturn {\n\t\t\ttype: AST.AssignmentExpression,\n\t\t\tleft: ast.body[0].expression,\n\t\t\tright: { type: AST.NGValueParameter },\n\t\t\toperator: \"=\",\n\t\t};\n\t}\n}\n\nfunction isLiteral(ast) {\n\treturn (\n\t\tast.body.length === 0 ||\n\t\t(ast.body.length === 1 &&\n\t\t\t(ast.body[0].expression.type === AST.Literal ||\n\t\t\t\tast.body[0].expression.type === AST.ArrayExpression ||\n\t\t\t\tast.body[0].expression.type === AST.ObjectExpression))\n\t);\n}\n\nfunction isConstant(ast) {\n\treturn ast.constant;\n}\n\nfunction ASTCompiler(astBuilder, $filter) {\n\tthis.astBuilder = astBuilder;\n\tthis.$filter = $filter;\n}\n\nASTCompiler.prototype = {\n\tcompile: function (expression) {\n\t\tvar self = this;\n\t\tvar ast = this.astBuilder.ast(expression);\n\t\tthis.state = {\n\t\t\tnextId: 0,\n\t\t\tfilters: {},\n\t\t\tfn: { vars: [], body: [], own: {} },\n\t\t\tassign: { vars: [], body: [], own: {} },\n\t\t\tinputs: [],\n\t\t};\n\t\tfindConstantAndWatchExpressions(ast, self.$filter);\n\t\tvar extra = \"\";\n\t\tvar assignable;\n\t\tthis.stage = \"assign\";\n\t\tif ((assignable = assignableAST(ast))) {\n\t\t\tthis.state.computing = \"assign\";\n\t\t\tvar result = this.nextId();\n\t\t\tthis.recurse(assignable, result);\n\t\t\tthis.return_(result);\n\t\t\textra = \"fn.assign=\" + this.generateFunction(\"assign\", \"s,v,l\");\n\t\t}\n\t\tvar toWatch = getInputs(ast.body);\n\t\tself.stage = \"inputs\";\n\t\tforEach(toWatch, function (watch, key) {\n\t\t\tvar fnKey = \"fn\" + key;\n\t\t\tself.state[fnKey] = { vars: [], body: [], own: {} };\n\t\t\tself.state.computing = fnKey;\n\t\t\tvar intoId = self.nextId();\n\t\t\tself.recurse(watch, intoId);\n\t\t\tself.return_(intoId);\n\t\t\tself.state.inputs.push(fnKey);\n\t\t\twatch.watchId = key;\n\t\t});\n\t\tthis.state.computing = \"fn\";\n\t\tthis.stage = \"main\";\n\t\tthis.recurse(ast);\n\t\tvar fnString =\n\t\t\t// The build and minification steps remove the string \"use strict\" from the code, but this is done using a regex.\n\t\t\t// This is a workaround for this until we do a better job at only removing the prefix only when we should.\n\t\t\t'\"' +\n\t\t\tthis.USE +\n\t\t\t\" \" +\n\t\t\tthis.STRICT +\n\t\t\t'\";\\n' +\n\t\t\tthis.filterPrefix() +\n\t\t\t\"var fn=\" +\n\t\t\tthis.generateFunction(\"fn\", \"s,l,a,i\") +\n\t\t\textra +\n\t\t\tthis.watchFns() +\n\t\t\t\"return fn;\";\n\n\t\t// eslint-disable-next-line no-new-func\n\t\tvar wrappedFn = new Function(\n\t\t\t\"$filter\",\n\t\t\t\"getStringValue\",\n\t\t\t\"ifDefined\",\n\t\t\t\"plus\",\n\t\t\tfnString\n\t\t)(this.$filter, getStringValue, ifDefined, plusFn);\n\n\t\tvar fn = function (s, l, a, i) {\n\t\t\treturn runWithFunctionConstructorProtection(function () {\n\t\t\t\treturn wrappedFn(s, l, a, i);\n\t\t\t});\n\t\t};\n\t\tfn.assign = function (s, v, l) {\n\t\t\treturn runWithFunctionConstructorProtection(function () {\n\t\t\t\treturn wrappedFn.assign(s, v, l);\n\t\t\t});\n\t\t};\n\t\tfn.inputs = wrappedFn.inputs;\n\n\t\tthis.state = this.stage = undefined;\n\t\tfn.ast = ast;\n\t\tfn.literal = isLiteral(ast);\n\t\tfn.constant = isConstant(ast);\n\t\treturn fn;\n\t},\n\n\tUSE: \"use\",\n\n\tSTRICT: \"strict\",\n\n\twatchFns: function () {\n\t\tvar result = [];\n\t\tvar fns = this.state.inputs;\n\t\tvar self = this;\n\t\tforEach(fns, function (name) {\n\t\t\tresult.push(\"var \" + name + \"=\" + self.generateFunction(name, \"s\"));\n\t\t});\n\t\tif (fns.length) {\n\t\t\tresult.push(\"fn.inputs=[\" + fns.join(\",\") + \"];\");\n\t\t}\n\t\treturn result.join(\"\");\n\t},\n\n\tgenerateFunction: function (name, params) {\n\t\treturn (\n\t\t\t\"function(\" +\n\t\t\tparams +\n\t\t\t\"){\" +\n\t\t\tthis.varsPrefix(name) +\n\t\t\tthis.body(name) +\n\t\t\t\"};\"\n\t\t);\n\t},\n\n\tfilterPrefix: function () {\n\t\tvar parts = [];\n\t\tvar self = this;\n\t\tforEach(this.state.filters, function (id, filter) {\n\t\t\tparts.push(id + \"=$filter(\" + self.escape(filter) + \")\");\n\t\t});\n\t\tif (parts.length) {\n\t\t\treturn \"var \" + parts.join(\",\") + \";\";\n\t\t}\n\t\treturn \"\";\n\t},\n\n\tvarsPrefix: function (section) {\n\t\treturn this.state[section].vars.length\n\t\t\t? \"var \" + this.state[section].vars.join(\",\") + \";\"\n\t\t\t: \"\";\n\t},\n\n\tbody: function (section) {\n\t\treturn this.state[section].body.join(\"\");\n\t},\n\n\trecurse: function (\n\t\tast,\n\t\tintoId,\n\t\tnameId,\n\t\trecursionFn,\n\t\tcreate,\n\t\tskipWatchIdCheck\n\t) {\n\t\tvar left,\n\t\t\tright,\n\t\t\tself = this,\n\t\t\targs,\n\t\t\texpression,\n\t\t\tcomputed;\n\t\trecursionFn = recursionFn || noop;\n\t\tif (!skipWatchIdCheck && isDefined(ast.watchId)) {\n\t\t\tintoId = intoId || this.nextId();\n\t\t\tthis.if_(\n\t\t\t\t\"i\",\n\t\t\t\tthis.lazyAssign(intoId, this.unsafeComputedMember(\"i\", ast.watchId)),\n\t\t\t\tthis.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (ast.type) {\n\t\t\tcase AST.Program:\n\t\t\t\tforEach(ast.body, function (expression, pos) {\n\t\t\t\t\tself.recurse(\n\t\t\t\t\t\texpression.expression,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tfunction (expr) {\n\t\t\t\t\t\t\tright = expr;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tif (pos !== ast.body.length - 1) {\n\t\t\t\t\t\tself.current().body.push(right, \";\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.return_(right);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase AST.Literal:\n\t\t\t\texpression = this.escape(ast.value);\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.UnaryExpression:\n\t\t\t\tthis.recurse(ast.argument, undefined, undefined, function (expr) {\n\t\t\t\t\tright = expr;\n\t\t\t\t});\n\t\t\t\texpression = ast.operator + \"(\" + this.ifDefined(right, 0) + \")\";\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.BinaryExpression:\n\t\t\t\tthis.recurse(ast.left, undefined, undefined, function (expr) {\n\t\t\t\t\tleft = expr;\n\t\t\t\t});\n\t\t\t\tthis.recurse(ast.right, undefined, undefined, function (expr) {\n\t\t\t\t\tright = expr;\n\t\t\t\t});\n\t\t\t\tif (ast.operator === \"+\") {\n\t\t\t\t\texpression = this.plus(left, right);\n\t\t\t\t} else if (ast.operator === \"-\") {\n\t\t\t\t\texpression =\n\t\t\t\t\t\tthis.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);\n\t\t\t\t} else {\n\t\t\t\t\texpression = \"(\" + left + \")\" + ast.operator + \"(\" + right + \")\";\n\t\t\t\t}\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.LogicalExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(ast.left, intoId);\n\t\t\t\tself.if_(\n\t\t\t\t\tast.operator === \"&&\" ? intoId : self.not(intoId),\n\t\t\t\t\tself.lazyRecurse(ast.right, intoId)\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.ConditionalExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(ast.test, intoId);\n\t\t\t\tself.if_(\n\t\t\t\t\tintoId,\n\t\t\t\t\tself.lazyRecurse(ast.alternate, intoId),\n\t\t\t\t\tself.lazyRecurse(ast.consequent, intoId)\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.Identifier:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tvar inAssignment = self.current().inAssignment;\n\t\t\t\tif (nameId) {\n\t\t\t\t\tif (inAssignment) {\n\t\t\t\t\t\tnameId.context = this.assign(this.nextId(), \"s\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnameId.context =\n\t\t\t\t\t\t\tself.stage === \"inputs\"\n\t\t\t\t\t\t\t\t? \"s\"\n\t\t\t\t\t\t\t\t: this.assign(\n\t\t\t\t\t\t\t\t\t\tthis.nextId(),\n\t\t\t\t\t\t\t\t\t\tthis.getHasOwnProperty(\"l\", ast.name) + \"?l:s\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tnameId.computed = false;\n\t\t\t\t\tnameId.name = ast.name;\n\t\t\t\t}\n\t\t\t\tself.if_(\n\t\t\t\t\tself.stage === \"inputs\" ||\n\t\t\t\t\t\tself.not(self.getHasOwnProperty(\"l\", ast.name)),\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.stage === \"inputs\" ||\n\t\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\t\t\"s\",\n\t\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\t\tself.isNull(self.nonComputedMember(\"s\", ast.name)),\n\t\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(\"s\", ast.name)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\t\t\t\tself.isNull(self.nonComputedMember(\"s\", ast.name)),\n\t\t\t\t\t\t\t\t\t\tself.lazyAssign(self.nonComputedMember(\"s\", ast.name), \"{}\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tself.assign(intoId, self.nonComputedMember(\"s\", ast.name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\tintoId &&\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\t\tself.hasOwnProperty_(\"l\", ast.name),\n\t\t\t\t\t\t\t\tself.lazyAssign(intoId, self.nonComputedMember(\"l\", ast.name))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.MemberExpression:\n\t\t\t\tleft = (nameId && (nameId.context = this.nextId())) || this.nextId();\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(\n\t\t\t\t\tast.object,\n\t\t\t\t\tleft,\n\t\t\t\t\tundefined,\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tvar member = null;\n\t\t\t\t\t\tvar inAssignment = self.current().inAssignment;\n\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\tright = self.nextId();\n\t\t\t\t\t\t\tif (inAssignment || self.state.computing === \"assign\") {\n\t\t\t\t\t\t\t\tmember = self.unsafeComputedMember(left, right);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmember = self.computedMember(left, right);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (inAssignment || self.state.computing === \"assign\") {\n\t\t\t\t\t\t\t\tmember = self.unsafeNonComputedMember(left, ast.property.name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmember = self.nonComputedMember(left, ast.property.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tright = ast.property.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\tif (ast.property.type === AST.Literal) {\n\t\t\t\t\t\t\t\tself.recurse(ast.property, right);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\tself.notNull(left),\n\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\tself.isNull(member),\n\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(left, right, ast.computed)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\t\t\tif (ast.property.type !== AST.Literal) {\n\t\t\t\t\t\t\t\t\t\tself.recurse(ast.property, right);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\t\tself.if_(self.not(member), self.lazyAssign(member, \"{}\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tself.assign(intoId, member);\n\t\t\t\t\t\t\t\t\tif (nameId) {\n\t\t\t\t\t\t\t\t\t\tnameId.computed = true;\n\t\t\t\t\t\t\t\t\t\tnameId.name = right;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\t\t\t\t\tself.isNull(member),\n\t\t\t\t\t\t\t\t\t\t\tself.lazyAssign(member, \"{}\")\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tself.assign(intoId, member);\n\t\t\t\t\t\t\t\t\tif (nameId) {\n\t\t\t\t\t\t\t\t\t\tnameId.computed = false;\n\t\t\t\t\t\t\t\t\t\tnameId.name = ast.property.name;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.assign(intoId, \"undefined\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t\t},\n\t\t\t\t\t!!create\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase AST.CallExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tif (ast.filter) {\n\t\t\t\t\tright = self.filter(ast.callee.name);\n\t\t\t\t\targs = [];\n\t\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\t\tvar argument = self.nextId();\n\t\t\t\t\t\tself.recurse(expr, argument);\n\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t});\n\t\t\t\t\texpression = right + \".call(\" + right + \",\" + args.join(\",\") + \")\";\n\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t} else {\n\t\t\t\t\tright = self.nextId();\n\t\t\t\t\tleft = {};\n\t\t\t\t\targs = [];\n\t\t\t\t\tself.recurse(ast.callee, right, left, function () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.notNull(right),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\t\t\t\t\tself.recurse(\n\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tfunction (argument) {\n\t\t\t\t\t\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (left.name) {\n\t\t\t\t\t\t\t\t\tvar x = self.member(left.context, left.name, left.computed);\n\t\t\t\t\t\t\t\t\texpression =\n\t\t\t\t\t\t\t\t\t\t\"(\" +\n\t\t\t\t\t\t\t\t\t\tx +\n\t\t\t\t\t\t\t\t\t\t\" === null ? null : \" +\n\t\t\t\t\t\t\t\t\t\tself.unsafeMember(left.context, left.name, left.computed) +\n\t\t\t\t\t\t\t\t\t\t\".call(\" +\n\t\t\t\t\t\t\t\t\t\t[left.context].concat(args).join(\",\") +\n\t\t\t\t\t\t\t\t\t\t\"))\";\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\texpression = right + \"(\" + args.join(\",\") + \")\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.assign(intoId, \"undefined\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AST.AssignmentExpression:\n\t\t\t\tright = this.nextId();\n\t\t\t\tleft = {};\n\t\t\t\tself.current().inAssignment = true;\n\t\t\t\tthis.recurse(\n\t\t\t\t\tast.left,\n\t\t\t\t\tundefined,\n\t\t\t\t\tleft,\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\tself.notNull(left.context),\n\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(left.context, left.name),\n\t\t\t\t\t\t\t\t\tself.isNull(\n\t\t\t\t\t\t\t\t\t\tself.member(left.context, left.name, left.computed)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.recurse(ast.right, right);\n\t\t\t\t\t\t\t\texpression =\n\t\t\t\t\t\t\t\t\tself.member(left.context, left.name, left.computed) +\n\t\t\t\t\t\t\t\t\tast.operator +\n\t\t\t\t\t\t\t\t\tright;\n\t\t\t\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tself.current().inAssignment = false;\n\t\t\t\t\t\tself.recurse(ast.right, right);\n\t\t\t\t\t\tself.current().inAssignment = true;\n\t\t\t\t\t},\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t\tself.current().inAssignment = false;\n\t\t\t\tbreak;\n\t\t\tcase AST.ArrayExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\t\tself.recurse(\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tfunction (argument) {\n\t\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\texpression = \"[\" + args.join(\",\") + \"]\";\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.ObjectExpression:\n\t\t\t\targs = [];\n\t\t\t\tcomputed = false;\n\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\tcomputed = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (computed) {\n\t\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\t\tthis.assign(intoId, \"{}\");\n\t\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\t\tleft = self.nextId();\n\t\t\t\t\t\t\tself.recurse(property.key, left);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft =\n\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t: \"\" + property.key.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright = self.nextId();\n\t\t\t\t\t\tself.recurse(property.value, right);\n\t\t\t\t\t\tself.assign(\n\t\t\t\t\t\t\tself.unsafeMember(intoId, left, property.computed),\n\t\t\t\t\t\t\tright\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\t\tself.recurse(\n\t\t\t\t\t\t\tproperty.value,\n\t\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tfunction (expr) {\n\t\t\t\t\t\t\t\targs.push(\n\t\t\t\t\t\t\t\t\tself.escape(\n\t\t\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t\t\t: \"\" + property.key.value\n\t\t\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t\t\t\t\":\" +\n\t\t\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\texpression = \"{\" + args.join(\",\") + \"}\";\n\t\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\t}\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.ThisExpression:\n\t\t\t\tthis.assign(intoId, \"s\");\n\t\t\t\trecursionFn(intoId || \"s\");\n\t\t\t\tbreak;\n\t\t\tcase AST.LocalsExpression:\n\t\t\t\tthis.assign(intoId, \"l\");\n\t\t\t\trecursionFn(intoId || \"l\");\n\t\t\t\tbreak;\n\t\t\tcase AST.NGValueParameter:\n\t\t\t\tthis.assign(intoId, \"v\");\n\t\t\t\trecursionFn(intoId || \"v\");\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\tgetHasOwnProperty: function (element, property) {\n\t\tvar key = element + \".\" + property;\n\t\tvar own = this.current().own;\n\t\tif (!own.hasOwnProperty(key)) {\n\t\t\town[key] = this.nextId(\n\t\t\t\tfalse,\n\t\t\t\telement + \"&&(\" + this.escape(property) + \" in \" + element + \")\"\n\t\t\t);\n\t\t}\n\t\treturn own[key];\n\t},\n\n\tassign: function (id, value) {\n\t\tif (!id) {\n\t\t\treturn;\n\t\t}\n\t\tthis.current().body.push(id, \"=\", value, \";\");\n\t\treturn id;\n\t},\n\n\tfilter: function (filterName) {\n\t\tif (!hasOwnProperty.call(this.state.filters, filterName)) {\n\t\t\tthis.state.filters[filterName] = this.nextId(true);\n\t\t}\n\t\treturn this.state.filters[filterName];\n\t},\n\n\tifDefined: function (id, defaultValue) {\n\t\treturn \"ifDefined(\" + id + \",\" + this.escape(defaultValue) + \")\";\n\t},\n\n\tplus: function (left, right) {\n\t\treturn \"plus(\" + left + \",\" + right + \")\";\n\t},\n\n\treturn_: function (id) {\n\t\tthis.current().body.push(\"return \", id, \";\");\n\t},\n\n\tif_: function (test, alternate, consequent) {\n\t\tif (test === true) {\n\t\t\talternate();\n\t\t} else {\n\t\t\tvar body = this.current().body;\n\t\t\tbody.push(\"if(\", test, \"){\");\n\t\t\talternate();\n\t\t\tbody.push(\"}\");\n\t\t\tif (consequent) {\n\t\t\t\tbody.push(\"else{\");\n\t\t\t\tconsequent();\n\t\t\t\tbody.push(\"}\");\n\t\t\t}\n\t\t}\n\t},\n\tor_: function (expr1, expr2) {\n\t\treturn \"(\" + expr1 + \") || (\" + expr2 + \")\";\n\t},\n\thasOwnProperty_: function (obj, prop, computed) {\n\t\tif (computed) {\n\t\t\treturn \"(Object.prototype.hasOwnProperty.call(\" + obj + \",\" + prop + \"))\";\n\t\t}\n\t\treturn \"(Object.prototype.hasOwnProperty.call(\" + obj + \",'\" + prop + \"'))\";\n\t},\n\tand_: function (expr1, expr2) {\n\t\treturn \"(\" + expr1 + \") && (\" + expr2 + \")\";\n\t},\n\tnot: function (expression) {\n\t\treturn \"!(\" + expression + \")\";\n\t},\n\n\tisNull: function (expression) {\n\t\treturn expression + \"==null\";\n\t},\n\n\tnotNull: function (expression) {\n\t\treturn expression + \"!=null\";\n\t},\n\n\tnonComputedMember: function (left, right) {\n\t\tvar SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;\n\t\tvar UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;\n\t\tvar expr = \"\";\n\t\tif (SAFE_IDENTIFIER.test(right)) {\n\t\t\texpr = left + \".\" + right;\n\t\t} else {\n\t\t\tright = right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn);\n\t\t\texpr = left + '[\"' + right + '\"]';\n\t\t}\n\n\t\treturn expr;\n\t},\n\n\tunsafeComputedMember: function (left, right) {\n\t\treturn left + \"[\" + right + \"]\";\n\t},\n\tunsafeNonComputedMember: function (left, right) {\n\t\treturn this.nonComputedMember(left, right);\n\t},\n\n\tcomputedMember: function (left, right) {\n\t\tif (this.state.computing === \"assign\") {\n\t\t\treturn this.unsafeComputedMember(left, right);\n\t\t}\n\t\t// return left + \"[\" + right + \"]\";\n\t\treturn (\n\t\t\t\"(\" +\n\t\t\tleft +\n\t\t\t\".hasOwnProperty(\" +\n\t\t\tright +\n\t\t\t\") ? \" +\n\t\t\tleft +\n\t\t\t\"[\" +\n\t\t\tright +\n\t\t\t\"] : undefined)\"\n\t\t);\n\t},\n\n\tunsafeMember: function (left, right, computed) {\n\t\tif (computed) {\n\t\t\treturn this.unsafeComputedMember(left, right);\n\t\t}\n\t\treturn this.unsafeNonComputedMember(left, right);\n\t},\n\n\tmember: function (left, right, computed) {\n\t\tif (computed) {\n\t\t\treturn this.computedMember(left, right);\n\t\t}\n\t\treturn this.nonComputedMember(left, right);\n\t},\n\n\tgetStringValue: function (item) {\n\t\tthis.assign(item, \"getStringValue(\" + item + \")\");\n\t},\n\n\tlazyRecurse: function (\n\t\tast,\n\t\tintoId,\n\t\tnameId,\n\t\trecursionFn,\n\t\tcreate,\n\t\tskipWatchIdCheck\n\t) {\n\t\tvar self = this;\n\t\treturn function () {\n\t\t\tself.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);\n\t\t};\n\t},\n\n\tlazyAssign: function (id, value) {\n\t\tvar self = this;\n\t\treturn function () {\n\t\t\tself.assign(id, value);\n\t\t};\n\t},\n\n\tstringEscapeRegex: /[^ a-zA-Z0-9]/g,\n\n\tstringEscapeFn: function (c) {\n\t\treturn \"\\\\u\" + (\"0000\" + c.charCodeAt(0).toString(16)).slice(-4);\n\t},\n\n\tescape: function (value) {\n\t\tif (isString(value)) {\n\t\t\treturn (\n\t\t\t\t\"'\" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + \"'\"\n\t\t\t);\n\t\t}\n\t\tif (isNumber(value)) {\n\t\t\treturn value.toString();\n\t\t}\n\t\tif (value === true) {\n\t\t\treturn \"true\";\n\t\t}\n\t\tif (value === false) {\n\t\t\treturn \"false\";\n\t\t}\n\t\tif (value === null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tif (typeof value === \"undefined\") {\n\t\t\treturn \"undefined\";\n\t\t}\n\n\t\tthrow $parseMinErr(\"esc\", \"IMPOSSIBLE\");\n\t},\n\n\tnextId: function (skip, init) {\n\t\tvar id = \"v\" + this.state.nextId++;\n\t\tif (!skip) {\n\t\t\tthis.current().vars.push(id + (init ? \"=\" + init : \"\"));\n\t\t}\n\t\treturn id;\n\t},\n\n\tcurrent: function () {\n\t\treturn this.state[this.state.computing];\n\t},\n};\n\nfunction ASTInterpreter(astBuilder, $filter) {\n\tthis.astBuilder = astBuilder;\n\tthis.$filter = $filter;\n}\n\nASTInterpreter.prototype = {\n\tcompile: function (expression) {\n\t\tvar self = this;\n\t\tvar ast = this.astBuilder.ast(expression);\n\t\tfindConstantAndWatchExpressions(ast, self.$filter);\n\t\tvar assignable;\n\t\tvar assign;\n\t\tif ((assignable = assignableAST(ast))) {\n\t\t\tassign = this.recurse(assignable);\n\t\t}\n\t\tvar toWatch = getInputs(ast.body);\n\t\tvar inputs;\n\t\tif (toWatch) {\n\t\t\tinputs = [];\n\t\t\tforEach(toWatch, function (watch, key) {\n\t\t\t\tvar input = self.recurse(watch);\n\t\t\t\twatch.input = input;\n\t\t\t\tinputs.push(input);\n\t\t\t\twatch.watchId = key;\n\t\t\t});\n\t\t}\n\t\tvar expressions = [];\n\t\tforEach(ast.body, function (expression) {\n\t\t\texpressions.push(self.recurse(expression.expression));\n\t\t});\n\t\tvar wrappedFn =\n\t\t\tast.body.length === 0\n\t\t\t\t? noop\n\t\t\t\t: ast.body.length === 1\n\t\t\t\t\t? expressions[0]\n\t\t\t\t\t: function (scope, locals) {\n\t\t\t\t\t\t\tvar lastValue;\n\t\t\t\t\t\t\tforEach(expressions, function (exp) {\n\t\t\t\t\t\t\t\tlastValue = exp(scope, locals);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn lastValue;\n\t\t\t\t\t\t};\n\n\t\tif (assign) {\n\t\t\twrappedFn.assign = function (scope, value, locals) {\n\t\t\t\treturn assign(scope, locals, value);\n\t\t\t};\n\t\t}\n\n\t\tvar fn = function (scope, locals) {\n\t\t\treturn runWithFunctionConstructorProtection(function () {\n\t\t\t\treturn wrappedFn(scope, locals);\n\t\t\t});\n\t\t};\n\t\tfn.assign = function (scope, value, locals) {\n\t\t\treturn runWithFunctionConstructorProtection(function () {\n\t\t\t\treturn wrappedFn.assign(scope, value, locals);\n\t\t\t});\n\t\t};\n\n\t\tif (inputs) {\n\t\t\tfn.inputs = inputs;\n\t\t}\n\t\tfn.ast = ast;\n\t\tfn.literal = isLiteral(ast);\n\t\tfn.constant = isConstant(ast);\n\t\treturn fn;\n\t},\n\n\trecurse: function (ast, context, create) {\n\t\tvar left,\n\t\t\tright,\n\t\t\tself = this,\n\t\t\targs;\n\t\tif (ast.input) {\n\t\t\treturn this.inputs(ast.input, ast.watchId);\n\t\t}\n\t\tswitch (ast.type) {\n\t\t\tcase AST.Literal:\n\t\t\t\treturn this.value(ast.value, context);\n\t\t\tcase AST.UnaryExpression:\n\t\t\t\tright = this.recurse(ast.argument);\n\t\t\t\treturn this[\"unary\" + ast.operator](right, context);\n\t\t\tcase AST.BinaryExpression:\n\t\t\t\tleft = this.recurse(ast.left);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn this[\"binary\" + ast.operator](left, right, context);\n\t\t\tcase AST.LogicalExpression:\n\t\t\t\tleft = this.recurse(ast.left);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn this[\"binary\" + ast.operator](left, right, context);\n\t\t\tcase AST.ConditionalExpression:\n\t\t\t\treturn this[\"ternary?:\"](\n\t\t\t\t\tthis.recurse(ast.test),\n\t\t\t\t\tthis.recurse(ast.alternate),\n\t\t\t\t\tthis.recurse(ast.consequent),\n\t\t\t\t\tcontext\n\t\t\t\t);\n\t\t\tcase AST.Identifier:\n\t\t\t\treturn self.identifier(ast.name, context, create);\n\t\t\tcase AST.MemberExpression:\n\t\t\t\tleft = this.recurse(ast.object, false, !!create);\n\t\t\t\tif (!ast.computed) {\n\t\t\t\t\tright = ast.property.name;\n\t\t\t\t}\n\t\t\t\tif (ast.computed) {\n\t\t\t\t\tright = this.recurse(ast.property);\n\t\t\t\t}\n\n\t\t\t\treturn ast.computed\n\t\t\t\t\t? this.computedMember(left, right, context, create)\n\t\t\t\t\t: this.nonComputedMember(left, right, context, create);\n\t\t\tcase AST.CallExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\targs.push(self.recurse(expr));\n\t\t\t\t});\n\t\t\t\tif (ast.filter) {\n\t\t\t\t\tright = this.$filter(ast.callee.name);\n\t\t\t\t}\n\t\t\t\tif (!ast.filter) {\n\t\t\t\t\tright = this.recurse(ast.callee, true);\n\t\t\t\t}\n\t\t\t\treturn ast.filter\n\t\t\t\t\t? function (scope, locals, assign, inputs) {\n\t\t\t\t\t\t\tvar values = [];\n\t\t\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\t\t\tvalues.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar value = right.apply(undefined, values, inputs);\n\t\t\t\t\t\t\treturn context\n\t\t\t\t\t\t\t\t? { context: undefined, name: undefined, value: value }\n\t\t\t\t\t\t\t\t: value;\n\t\t\t\t\t\t}\n\t\t\t\t\t: function (scope, locals, assign, inputs) {\n\t\t\t\t\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\t\t\t\t\tvar value;\n\t\t\t\t\t\t\tif (rhs.value != null) {\n\t\t\t\t\t\t\t\tvar values = [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\t\t\t\tvalues.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalue = rhs.value.apply(rhs.context, values);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t\t\t};\n\t\t\tcase AST.AssignmentExpression:\n\t\t\t\tleft = this.recurse(ast.left, true, 1);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar lhs = left(scope, false, assign, inputs);\n\t\t\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\t\t\tlhs.context[lhs.name] = rhs;\n\t\t\t\t\treturn context ? { value: rhs } : rhs;\n\t\t\t\t};\n\t\t\tcase AST.ArrayExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\t\targs.push(self.recurse(expr));\n\t\t\t\t});\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar value = [];\n\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tvalue.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t}\n\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t};\n\t\t\tcase AST.ObjectExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\targs.push({\n\t\t\t\t\t\t\tkey: self.recurse(property.key),\n\t\t\t\t\t\t\tcomputed: true,\n\t\t\t\t\t\t\tvalue: self.recurse(property.value),\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push({\n\t\t\t\t\t\t\tkey:\n\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t: \"\" + property.key.value,\n\t\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\t\tvalue: self.recurse(property.value),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar value = {};\n\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tif (args[i].computed) {\n\t\t\t\t\t\t\tvalue[args[i].key(scope, locals, assign, inputs)] = args[i].value(\n\t\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\t\tlocals,\n\t\t\t\t\t\t\t\tassign,\n\t\t\t\t\t\t\t\tinputs\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue[args[i].key] = args[i].value(scope, locals, assign, inputs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t};\n\t\t\tcase AST.ThisExpression:\n\t\t\t\treturn function (scope) {\n\t\t\t\t\treturn context ? { value: scope } : scope;\n\t\t\t\t};\n\t\t\tcase AST.LocalsExpression:\n\t\t\t\treturn function (scope, locals) {\n\t\t\t\t\treturn context ? { value: locals } : locals;\n\t\t\t\t};\n\t\t\tcase AST.NGValueParameter:\n\t\t\t\treturn function (scope, locals, assign) {\n\t\t\t\t\treturn context ? { value: assign } : assign;\n\t\t\t\t};\n\t\t}\n\t},\n\n\t\"unary+\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = argument(scope, locals, assign, inputs);\n\t\t\tif (isDefined(arg)) {\n\t\t\t\targ = +arg;\n\t\t\t} else {\n\t\t\t\targ = 0;\n\t\t\t}\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"unary-\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = argument(scope, locals, assign, inputs);\n\t\t\tif (isDefined(arg)) {\n\t\t\t\targ = -arg;\n\t\t\t} else {\n\t\t\t\targ = -0;\n\t\t\t}\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"unary!\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = !argument(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary+\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\tvar arg = plusFn(lhs, rhs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary-\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\tvar arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary*\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) *\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary/\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) /\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary%\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) %\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary===\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ===\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary!==\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) !==\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary==\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ==\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary!=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) !=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary<\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) <\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary>\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) >\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary<=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) <=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary>=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) >=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary&&\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) &&\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary||\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ||\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"ternary?:\": function (test, alternate, consequent, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = test(scope, locals, assign, inputs)\n\t\t\t\t? alternate(scope, locals, assign, inputs)\n\t\t\t\t: consequent(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\tvalue: function (value, context) {\n\t\treturn function () {\n\t\t\treturn context\n\t\t\t\t? { context: undefined, name: undefined, value: value }\n\t\t\t\t: value;\n\t\t};\n\t},\n\tidentifier: function (name, context, create) {\n\t\treturn function (scope, locals) {\n\t\t\tvar base = locals && name in locals ? locals : scope;\n\t\t\tif (create && create !== 1 && base && base[name] == null) {\n\t\t\t\tbase[name] = {};\n\t\t\t}\n\t\t\tvar value;\n\t\t\tif (base && hasOwnProperty.call(base, name)) {\n\t\t\t\tvalue = base ? base[name] : undefined;\n\t\t\t}\n\t\t\tif (context) {\n\t\t\t\treturn { context: base, name: name, value: value };\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\t},\n\tcomputedMember: function (left, right, context, create) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs;\n\t\t\tvar value;\n\t\t\tif (lhs != null) {\n\t\t\t\trhs = right(scope, locals, assign, inputs);\n\t\t\t\trhs = getStringValue(rhs);\n\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\tif (lhs && !lhs[rhs]) {\n\t\t\t\t\t\tlhs[rhs] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(lhs, rhs)) {\n\t\t\t\t\tvalue = lhs[rhs];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (context) {\n\t\t\t\treturn { context: lhs, name: rhs, value: value };\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\t},\n\tnonComputedMember: function (left, right, context, create) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tif (create && create !== 1) {\n\t\t\t\tif (lhs && lhs[right] == null) {\n\t\t\t\t\tlhs[right] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar value = undefined;\n\t\t\tif (lhs != null && Object.prototype.hasOwnProperty.call(lhs, right)) {\n\t\t\t\tvalue = lhs[right];\n\t\t\t}\n\n\t\t\tif (context) {\n\t\t\t\treturn { context: lhs, name: right, value: value };\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\t},\n\tinputs: function (input, watchId) {\n\t\treturn function (scope, value, locals, inputs) {\n\t\t\tif (inputs) {\n\t\t\t\treturn inputs[watchId];\n\t\t\t}\n\t\t\treturn input(scope, value, locals);\n\t\t};\n\t},\n};\n\n/**\n * @constructor\n */\nvar Parser = function Parser(lexer, $filter, options) {\n\tthis.lexer = lexer;\n\tthis.$filter = $filter;\n\toptions = options || {};\n\toptions.handleThis = options.handleThis != null ? options.handleThis : true;\n\tthis.options = options;\n\tthis.ast = new AST(lexer, options);\n\tthis.ast.selfReferential = {\n\t\t$locals: { type: AST.LocalsExpression },\n\t};\n\tif (options.handleThis) {\n\t\tthis.ast.selfReferential.this = { type: AST.ThisExpression };\n\t}\n\tthis.astCompiler = options.csp\n\t\t? new ASTInterpreter(this.ast, $filter)\n\t\t: new ASTCompiler(this.ast, $filter);\n};\n\nParser.prototype = {\n\tconstructor: Parser,\n\n\tparse: function (text) {\n\t\treturn this.astCompiler.compile(text);\n\t},\n};\n\nexports.Lexer = Lexer;\nexports.Parser = Parser;\n","/**\n * marked v15.0.8 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n'use strict';\n\n/**\n * Gets the original marked default options.\n */\nfunction _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\nexports.defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    exports.defaults = newDefaults;\n}\n\nconst noopTest = { exec: () => null };\nfunction edit(regex, opt = '') {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(other.caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\nconst other = {\n    codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n    outputLinkReplace: /\\\\([\\[\\]])/g,\n    indentCodeCompensation: /^(\\s+)(?:```)/,\n    beginningSpace: /^\\s+/,\n    endingHash: /#$/,\n    startingSpaceChar: /^ /,\n    endingSpaceChar: / $/,\n    nonSpaceChar: /[^ ]/,\n    newLineCharGlobal: /\\n/g,\n    tabCharGlobal: /\\t/g,\n    multipleSpaceGlobal: /\\s+/g,\n    blankLine: /^[ \\t]*$/,\n    doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n    blockquoteStart: /^ {0,3}>/,\n    blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n    blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n    listReplaceTabs: /^\\t+/,\n    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n    listIsTask: /^\\[[ xX]\\] /,\n    listReplaceTask: /^\\[[ xX]\\] +/,\n    anyLine: /\\n.*\\n/,\n    hrefBrackets: /^<(.*)>$/,\n    tableDelimiter: /[:|]/,\n    tableAlignChars: /^\\||\\| *$/g,\n    tableRowBlankLine: /\\n[ \\t]*$/,\n    tableAlignRight: /^ *-+: *$/,\n    tableAlignCenter: /^ *:-+: *$/,\n    tableAlignLeft: /^ *:-+ *$/,\n    startATag: /^<a /i,\n    endATag: /^<\\/a>/i,\n    startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n    endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n    startAngleBracket: /^</,\n    endAngleBracket: />$/,\n    pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n    unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n    escapeTest: /[&<>\"']/,\n    escapeReplace: /[&<>\"']/g,\n    escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n    escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n    unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n    caret: /(^|[^\\[])\\^/g,\n    percentDecode: /%25/g,\n    findPipe: /\\|/g,\n    splitPipe: / \\|/,\n    slashPipe: /\\\\\\|/g,\n    carriageReturn: /\\r\\n|\\r/g,\n    spaceLine: /^ +$/gm,\n    notSpaceStart: /^\\S*/,\n    endingNewline: /\\n$/,\n    listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n    nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n    hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n    fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n    headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n    htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .replace(/\\|table/g, '') // table not in commonmark\n    .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    lheading: lheadingGfm,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n/**\n * Inline-Level Grammar\n */\nconst escape$1 = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n    .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n    .replace(/punct/g, _punctuationGfmStrongEm)\n    .getRegex();\nconst emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n    + '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n    .replace(/punctSpace/g, _punctuationOrSpace)\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n    .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n    .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n    .replace(/punct/g, _punctuationGfmStrongEm)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n    + '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n    .replace(/punctSpace/g, _punctuationOrSpace)\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape: escape$1,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    emStrongRDelimAst: emStrongRDelimAstGfm,\n    emStrongLDelim: emStrongLDelimGfm,\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n/**\n * exports\n */\nconst block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n\n/**\n * Helpers\n */\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (other.escapeTest.test(html)) {\n            return html.replace(other.escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (other.escapeTestNoEncode.test(html)) {\n            return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(other.percentDecode, '%');\n    }\n    catch {\n        return null;\n    }\n    return href;\n}\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(other.splitPipe);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells.at(-1)?.trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && true) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nfunction outputLink(cap, link, raw, lexer, rules) {\n    const href = link.href;\n    const title = link.title || null;\n    const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text,\n    };\n}\nfunction indentCodeCompensation(raw, text, rules) {\n    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(rules.other.beginningSpace);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nclass _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || exports.defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (this.rules.other.endingHash.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n'),\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], '\\n').split('\\n');\n            let raw = '';\n            let text = '';\n            const tokens = [];\n            while (lines.length > 0) {\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for (i = 0; i < lines.length; i++) {\n                    // get lines up to a continuation\n                    if (this.rules.other.blockquoteStart.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    }\n                    else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join('\\n');\n                const currentText = currentRaw\n                    // precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n                    .replace(this.rules.other.blockquoteSetextReplace2, '');\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'code') {\n                    // blockquote continuation cannot be preceded by a code block\n                    break;\n                }\n                else if (lastToken?.type === 'blockquote') {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                }\n                else if (lastToken?.type === 'list') {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens.at(-1).raw.length).split('\\n');\n                    continue;\n                }\n            }\n            return {\n                type: 'blockquote',\n                raw,\n                tokens,\n                text,\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = this.rules.other.listItemRegex(bull);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                let raw = '';\n                let itemContents = '';\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else if (blankLine) {\n                    indent = cap[1].length + 1;\n                }\n                else {\n                    indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                    const hrRegex = this.rules.other.hrRegex(indent);\n                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n                            nextLineWithoutTabs = nextLine;\n                        }\n                        else {\n                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (this.rules.other.doubleBlankLine.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = this.rules.other.listIsTask.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            const lastItem = list.items.at(-1);\n            if (lastItem) {\n                lastItem.raw = lastItem.raw.trimEnd();\n                lastItem.text = lastItem.text.trimEnd();\n            }\n            else {\n                // not a list since there were no items\n                return;\n            }\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!this.rules.other.tableDelimiter.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n        const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (this.rules.other.tableAlignRight.test(align)) {\n                item.align.push('right');\n            }\n            else if (this.rules.other.tableAlignCenter.test(align)) {\n                item.align.push('center');\n            }\n            else if (this.rules.other.tableAlignLeft.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i],\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i],\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: cap[1],\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = this.rules.other.pedanticHrefTitle.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (this.rules.other.startAngleBracket.test(href)) {\n                if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer, this.rules);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer, this.rules);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = cap[1];\n                href = 'mailto:' + text;\n            }\n            else {\n                text = cap[1];\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = cap[0];\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = cap[0];\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            const escaped = this.lexer.state.inRawBlock;\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                escaped,\n            };\n        }\n    }\n}\n\n/**\n * Block Lexer\n */\nclass _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || exports.defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n        const rules = {\n            other,\n            block: block.normal,\n            inline: inline.normal,\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src.replace(other.carriageReturn, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n        }\n        while (src) {\n            let token;\n            if (this.options.extensions?.block?.some((extTokenizer) => {\n                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.raw.length === 1 && lastToken !== undefined) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    lastToken.raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title,\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                const lastToken = tokens.at(-1);\n                if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match = null;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index)\n                            + '[' + 'a'.repeat(match[0].length - 2) + ']'\n                            + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        let keepPrevChar = false;\n        let prevChar = '';\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            let token;\n            // extensions\n            if (this.options.extensions?.inline?.some((extTokenizer) => {\n                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.type === 'text' && lastToken?.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n\n/**\n * Renderer\n */\nclass _Renderer {\n    options;\n    parser; // set by the parser\n    constructor(options) {\n        this.options = options || exports.defaults;\n    }\n    space(token) {\n        return '';\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || '').match(other.notSpaceStart)?.[0];\n        const code = text.replace(other.endingNewline, '') + '\\n';\n        if (!langString) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape(langString)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return '<hr>\\n';\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n                if (item.tokens[0]?.type === 'paragraph') {\n                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n                        item.tokens[0].tokens[0].escaped = true;\n                    }\n                }\n                else {\n                    item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                        escaped: true,\n                    });\n                }\n            }\n            else {\n                itemBody += checkbox + ' ';\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({ text: cell });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = '';\n            for (let k = 0; k < row.length; k++) {\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n        }\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align\n            ? `<${type} align=\"${token.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${escape(text, true)}</code>`;\n    }\n    br(token) {\n        return '<br>';\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + (escape(title)) + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return escape(text);\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${escape(title)}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(token) {\n        return 'tokens' in token && token.tokens\n            ? this.parser.parseInline(token.tokens)\n            : ('escaped' in token && token.escaped ? token.text : escape(token.text));\n    }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return '' + text;\n    }\n    image({ text }) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n\n/**\n * Parsing & Compiling\n */\nclass _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || exports.defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'space': {\n                    out += this.renderer.space(token);\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr(token);\n                    continue;\n                }\n                case 'heading': {\n                    out += this.renderer.heading(token);\n                    continue;\n                }\n                case 'code': {\n                    out += this.renderer.code(token);\n                    continue;\n                }\n                case 'table': {\n                    out += this.renderer.table(token);\n                    continue;\n                }\n                case 'blockquote': {\n                    out += this.renderer.blockquote(token);\n                    continue;\n                }\n                case 'list': {\n                    out += this.renderer.list(token);\n                    continue;\n                }\n                case 'html': {\n                    out += this.renderer.html(token);\n                    continue;\n                }\n                case 'paragraph': {\n                    out += this.renderer.paragraph(token);\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = this.renderer.text(textToken);\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + this.renderer.text(textToken);\n                    }\n                    if (top) {\n                        out += this.renderer.paragraph({\n                            type: 'paragraph',\n                            raw: body,\n                            text: body,\n                            tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n                        });\n                    }\n                    else {\n                        out += body;\n                    }\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer = this.renderer) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'escape': {\n                    out += renderer.text(token);\n                    break;\n                }\n                case 'html': {\n                    out += renderer.html(token);\n                    break;\n                }\n                case 'link': {\n                    out += renderer.link(token);\n                    break;\n                }\n                case 'image': {\n                    out += renderer.image(token);\n                    break;\n                }\n                case 'strong': {\n                    out += renderer.strong(token);\n                    break;\n                }\n                case 'em': {\n                    out += renderer.em(token);\n                    break;\n                }\n                case 'codespan': {\n                    out += renderer.codespan(token);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br(token);\n                    break;\n                }\n                case 'del': {\n                    out += renderer.del(token);\n                    break;\n                }\n                case 'text': {\n                    out += renderer.text(token);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n\nclass _Hooks {\n    options;\n    block;\n    constructor(options) {\n        this.options = options || exports.defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */\n    provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */\n    provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\n\nclass Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.parseMarkdown(true);\n    parseInline = this.parseMarkdown(false);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (['options', 'parser'].includes(prop)) {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (['options', 'block'].includes(prop)) {\n                        // ignore options and block properties\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n            }\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n            const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = exports.defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n\nexports.Hooks = _Hooks;\nexports.Lexer = _Lexer;\nexports.Marked = Marked;\nexports.Parser = _Parser;\nexports.Renderer = _Renderer;\nexports.TextRenderer = _TextRenderer;\nexports.Tokenizer = _Tokenizer;\nexports.getDefaults = _getDefaults;\nexports.lexer = lexer;\nexports.marked = marked;\nexports.options = options;\nexports.parse = parse;\nexports.parseInline = parseInline;\nexports.parser = parser;\nexports.setOptions = setOptions;\nexports.use = use;\nexports.walkTokens = walkTokens;\n//# sourceMappingURL=marked.cjs.map\n","declare function runFetchInContentScript(url?: string | URL, options?: RequestInit): Promise<Document>;\r\n\r\n// Type for the object created from FormData\r\ntype FormDataObject = Record<string, FormDataEntryValue>; // FormDataEntryValue is string | File\r\n\r\n// Interface for individual submission steps\r\ninterface SubmitInstruction {\r\n  url?: string | ((doc?: Document, set?: any, props?: Properties) => string | Promise<string>);\r\n  group?: string; // Used by groupBy\r\n  method?: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\" | \"OPTIONS\" | \"HEAD\"; // Common HTTP methods\r\n  body?: boolean; // Default: true, whether to include body\r\n  urlParams?: Record<string, any> | ((doc?: Document, set?: any, props?: Properties) => Record<string, any> | Promise<Record<string, any>>);\r\n  formDataTarget?: number; // Index in previousFormData to use\r\n  clearWizardFormData?: boolean; // Flag to clear current page's form data\r\n  clearVIEWFormData?: boolean; // Flag to clear accumulated form data\r\n  optional?: (doc?: Document, props?: Properties) => boolean; // Condition to skip this step\r\n  after?: (doc?: Document) => void; // Callback after successful fetch/parse\r\n  next?: boolean; // Flag for early return from the entire function\r\n  attempts?: number; // Retries for parsePage\r\n  sameorigin?: boolean; // Determines fetch method (content script vs background)\r\n}\r\n\r\n// Type for dynamic grouping parameters\r\n// The value can be a function returning an array of parameters, or just an array.\r\n// Using 'any' for the array elements as structure isn't defined here.\r\ntype GroupedRepeats = Record<string, ((props?: Properties) => any[]) | any[]>;\r\n\r\n// Interface for the main configuration object\r\nexport interface DataParams {\r\n  submit: SubmitInstruction[]; // Array of submission steps\r\n  action?: (doc?: Document) => void; // Initial action\r\n  groupRepeats?: GroupedRepeats; // Dynamic parameters for groups\r\n  afterAction?: (doc?: Document, props?: Properties) => void; // Action after all loops complete\r\n  next?: boolean; // Final return flag for the entire function\r\n}\r\n\r\n// Interface for the properties object passed around\r\ninterface Properties {\r\n  portDisconnected?: boolean;\r\n  // Add other known properties here\r\n  [key: string]: any; // Allow other arbitrary properties\r\n}\r\n\r\n// --- Helper Functions ---\r\n\r\n/**\r\n * Groups an array of objects by a specified property.\r\n * Items without the property or where the property is undefined are placed in \"Ungrouped\".\r\n * @template T - The type of objects in the array.\r\n * @param {T[]} arr - The array to group.\r\n * @param {string} property - The name of the property to group by.\r\n * @returns {Record<string, T[]>} - An object where keys are property values and values are arrays of matching objects.\r\n */\r\nfunction groupBy<T extends Record<string, any>>(arr: T[], property: string): Record<string, T[]> {\r\n  return arr.reduce((memo: Record<string, T[]>, x: T) => {\r\n    let key = x[property];\r\n    // Assign to 'Ungrouped' if the property doesn't exist or is undefined\r\n    if (key === undefined || key === null) {\r\n      key = \"Ungrouped\";\r\n    } else {\r\n      key = String(key); // Ensure key is a string\r\n    }\r\n\r\n    if (!memo[key]) {\r\n      memo[key] = [];\r\n    }\r\n    memo[key].push(x);\r\n    return memo;\r\n  }, {});\r\n}\r\n\r\n/**\r\n * Extracts form data from the first <form> element found in a Document.\r\n * @param {Document} targetDocument - The Document to search for a form.\r\n * @returns {Promise<FormDataObject>} - A promise resolving to an object containing the form data.\r\n */\r\nasync function getFormData(targetDocument: Document): Promise<FormDataObject> {\r\n  // Find the first form element, or create a dummy one if none exists to avoid errors with FormData constructor\r\n  const formElement = targetDocument.querySelector<HTMLFormElement>(\"form\") ?? document.createElement('form');\r\n  const formData = new FormData(formElement);\r\n  const formDataObject: FormDataObject = {};\r\n  formData.forEach((value, key) => {\r\n    formDataObject[key] = value;\r\n  });\r\n  return formDataObject;\r\n}\r\n\r\n/**\r\n * Parses the text content of a Response object into an HTML Document.\r\n * Includes a retry mechanism if reading the response body times out.\r\n * @param {Response} vDocument - The Response object from a fetch call.\r\n * @param {string} url - The original URL fetched (for retries).\r\n * @param {RequestInit} fetchOptions - The original fetch options (for retries).\r\n * @returns {Promise<Document>} - A promise resolving to the parsed Document.\r\n */\r\nasync function parsePage(vDocument: Response, url: string, fetchOptions: RequestInit): Promise<Document> {\r\n  // Helper to get response body with timeout\r\n  const getBodyWithTimeout = (response: Response, timeout = 10000): Promise<string> => {\r\n    return new Promise((resolve, reject) => {\r\n      const timer = setTimeout(() => {\r\n        reject(new Error(`getBodyWithTimeout timed out after ${timeout}ms for URL: ${url}`));\r\n      }, timeout);\r\n\r\n      response.text().then(\r\n        (text) => {\r\n          clearTimeout(timer);\r\n          resolve(text);\r\n        },\r\n        (err) => {\r\n          clearTimeout(timer);\r\n          reject(err); // Propagate fetch error\r\n        }\r\n      );\r\n    });\r\n  };\r\n\r\n  let htmlText: string;\r\n  try {\r\n    htmlText = await getBodyWithTimeout(vDocument);\r\n  } catch (e) {\r\n    console.warn(`Initial parsing failed or timed out for ${url}, retrying fetch...`, e);\r\n    // Retry the fetch and parsing on error/timeout\r\n    const retryResponse = await fetch(url, fetchOptions); // Assuming fetch handles its own retries\r\n    htmlText = await getBodyWithTimeout(retryResponse); // Try getting body again\r\n  }\r\n\r\n  const parser = new DOMParser();\r\n  const parsedDoc = parser.parseFromString(htmlText, \"text/html\");\r\n  return parsedDoc;\r\n}\r\n\r\n\r\n// --- Main VIEWsubmit Function ---\r\n\r\n/**\r\n * Handles a potentially multi-step view/form submission process.\r\n *\r\n * @param data - (Currently unused in snippet) Additional data. Type 'any' for flexibility.\r\n * @param incrementor - (Currently unused in snippet) Function or object for incrementing. Type 'any'.\r\n * @param initialParsedDocument - The parsed Document from a *previous* step, if applicable.\r\n * @param dataParams - Configuration object defining the submission steps and logic.\r\n * @param [properties={}] - Optional object containing state or configuration flags.\r\n * @returns {Promise<Document | boolean>} - Resolves to the final parsed Document, or a boolean based on 'next' flags.\r\n * @throws {string | Error} - Throws if properties.portDisconnected is true.\r\n */\r\nasync function VIEWsubmit(\r\n  data: any, // Unused in snippet, keep as any or specify if known\r\n  incrementor: any, // Unused in snippet, keep as any or specify if known\r\n  initialParsedDocument: Document | undefined,\r\n  dataParams: DataParams,\r\n  properties: Properties = {}\r\n): Promise<Document | boolean> {\r\n\r\n  let currentFormData: FormDataObject = {}; // Form data accumulated/used in the current step\r\n  const previousFormData: FormDataObject[] = []; // History of formData objects\r\n  let lastParsedDocument: Document | undefined = initialParsedDocument;\r\n\r\n  // Get initial form data from the previous step's document, if provided\r\n  if (lastParsedDocument) {\r\n    currentFormData = await getFormData(lastParsedDocument);\r\n  };\r\n\r\n  // Execute initial action, if defined\r\n  dataParams.action?.(lastParsedDocument);\r\n\r\n  // Group submission instructions\r\n  const groups = groupBy<SubmitInstruction>(dataParams.submit, \"group\"); // Explicit generic type\r\n\r\n  const groupedRepeats = dataParams.groupRepeats || { Ungrouped: () => [{}] }; // Default repeat structure\r\n\r\n  // Iterate through each group of submit instructions\r\n  for (const [groupName, group] of Object.entries(groups)) {\r\n    // Determine dynamic parameters for this group, default to [{}] for one iteration\r\n    const groupRepeatsFnOrArray = groupedRepeats[groupName];\r\n    const dynamicParams: any[] = typeof groupRepeatsFnOrArray === \"function\"\r\n      ? groupRepeatsFnOrArray(properties)\r\n      : (Array.isArray(groupRepeatsFnOrArray) ? groupRepeatsFnOrArray : [{}]); // Ensure it's an array\r\n\r\n    // Iterate through dynamic parameter sets for the current group\r\n    for (const set of dynamicParams) {\r\n      // Iterate through instructions within the current group and set\r\n      for (const submitInstructions of group) {\r\n        if (properties.portDisconnected) {\r\n          throw new Error(\"Window Closed\"); // Throw an Error object\r\n        }\r\n\r\n        // Check if this instruction step is optional and should be skipped\r\n        if (submitInstructions.optional?.(lastParsedDocument, properties) === false) {\r\n          continue; // Skip this instruction\r\n        }\r\n\r\n        // Calculate URL parameters, handling sync/async functions or static objects\r\n        let urlParamsResult = typeof submitInstructions.urlParams === \"function\"\r\n          ? submitInstructions.urlParams(lastParsedDocument, set, properties)\r\n          : submitInstructions.urlParams;\r\n        // Await if the result is a Promise, otherwise use directly\r\n        const resolvedUrlParams: Record<string, any> | undefined = await urlParamsResult;\r\n\r\n        // Get form data from the *current* wizard page (the live document)\r\n        let wizardPageFormData = await getFormData(document); // Use global 'document'\r\n\r\n        // Store the current state of formData before potentially modifying it\r\n        previousFormData.push(currentFormData);\r\n\r\n        // Determine which previous formData state to use as the base (default: last one)\r\n        const index = submitInstructions.formDataTarget ?? previousFormData.length - 1;\r\n        if (index >= 0 && index < previousFormData.length) {\r\n          currentFormData = previousFormData[index];\r\n        } else {\r\n          console.warn(`formDataTarget index ${index} out of bounds. Using last available form data.`);\r\n          currentFormData = previousFormData[previousFormData.length - 1] || {};\r\n        }\r\n\r\n\r\n        // Optionally clear form data based on flags\r\n        if (submitInstructions.clearWizardFormData) {\r\n          wizardPageFormData = {};\r\n        }\r\n        if (submitInstructions.clearVIEWFormData) {\r\n          currentFormData = {};\r\n        }\r\n\r\n        // Merge form data: base + URL params + current wizard page data\r\n        // Ensure resolvedUrlParams is an object before spreading\r\n        const mergedFormData = {\r\n          ...currentFormData,\r\n          ...(resolvedUrlParams && typeof resolvedUrlParams === 'object' ? resolvedUrlParams : {}),\r\n          ...wizardPageFormData\r\n        };\r\n\r\n        // Create FormData for the fetch request body\r\n        const fetchFormData = new FormData();\r\n        for (const key in mergedFormData) {\r\n          // FormData can handle string or Blob/File. Ensure value is not object/array.\r\n          if (Object.prototype.hasOwnProperty.call(mergedFormData, key) && typeof mergedFormData[key] !== 'object') {\r\n            fetchFormData.append(key, mergedFormData[key]);\r\n          } else if (mergedFormData[key] instanceof File || mergedFormData[key] instanceof Blob) {\r\n            fetchFormData.append(key, mergedFormData[key]);\r\n          }\r\n          // Note: Complex objects/arrays are skipped here. Handle serialization if needed.\r\n        }\r\n\r\n        // Prepare fetch options\r\n        const fetchOptions: RequestInit = {\r\n          method: submitInstructions.method || \"POST\",\r\n          headers: {\r\n            \"x-civica-application\": \"CE\",\r\n            \"sec-fetch-site\": \"same-origin\",\r\n            // Add other headers if necessary\r\n          },\r\n        };\r\n\r\n        if (submitInstructions.body !== false) { // Include body unless explicitly false\r\n          fetchOptions.body = fetchFormData;\r\n        }\r\n\r\n        // Determine the fetch URL, handling sync/async functions\r\n        let urlResult = typeof submitInstructions.url === 'function'\r\n          ? submitInstructions.url(lastParsedDocument, set, properties)\r\n          : submitInstructions.url;\r\n        const targetUrl: string | undefined = await urlResult; // Await if it's a promise\r\n\r\n\r\n        console.log(\"-------------------------\");\r\n        console.log(`Workspaceing: ${targetUrl} with method ${fetchOptions.method}`);\r\n        // Perform the fetch operation\r\n        let fetchResponse: Response | Document; // Type depends on branch\r\n        \r\n        // Ensure targetUrl is defined before proceeding\r\n        if (!targetUrl) {\r\n          throw new Error(\"Target URL is undefined for fetch operation\");\r\n        }\r\n        \r\n        if (submitInstructions.sameorigin) {\r\n          // Assumes runFetchInContentScript directly returns a parsed Document\r\n          fetchResponse = await runFetchInContentScript(targetUrl, fetchOptions);\r\n          lastParsedDocument = fetchResponse; // Update lastParsedDocument directly\r\n        } else {\r\n          fetchResponse = await fetch(targetUrl, fetchOptions);\r\n          const attempts = submitInstructions.attempts || 3; // Use specified attempts or default\r\n          // Parse the response (handles retries internally if needed)\r\n          lastParsedDocument = await parsePage(fetchResponse, targetUrl, fetchOptions);\r\n        }\r\n\r\n\r\n        // Update formData based on the *newly* parsed document for the next iteration/step\r\n        currentFormData = await getFormData(lastParsedDocument);\r\n\r\n\r\n        // Execute post-fetch action for this instruction\r\n        submitInstructions.after?.(lastParsedDocument);\r\n\r\n        // Check for early return based on instruction flag\r\n        if (submitInstructions.next === true) {\r\n          return true;\r\n        }\r\n      } // End loop: submitInstructions\r\n    } // End loop: set (dynamicParams)\r\n  } // End loop: groupName (groups)\r\n\r\n  // Execute final action after all groups/steps are processed\r\n  dataParams.afterAction?.(lastParsedDocument, properties);\r\n\r\n  // Final return based on dataParams flag\r\n  if (dataParams.next === true) {\r\n    return true;\r\n  }\r\n  if (dataParams.next === false) {\r\n    return false;\r\n  }\r\n\r\n  // Default return: the last parsed document or false if undefined\r\n  return lastParsedDocument || false;\r\n}\r\n\r\nexport default VIEWsubmit;","import Sqrl from 'squirrelly'\r\nimport marked from 'marked';\r\n\r\nconst templateMap = {\r\n\t'Report Needed': 'https://trimapi.justice.vic.gov.au/record/13724486/File/document2',\r\n\t'MOU': {\r\n\t\t'Agency FR Granted': 'https://trimapi.justice.vic.gov.au/record/21673543/File/document2',\r\n\t\t'default': 'https://trimapi.justice.vic.gov.au/record/13733834/File/document2'\r\n\t},\r\n\t'Unable to Contact Applicant': 'https://trimapi.justice.vic.gov.au/record/13735474/File/document2',\r\n\t'FVS Further Information Required': 'https://trimapi.justice.vic.gov.au/record/15111431/File/document2',\r\n\t'Further Information Required': 'https://trimapi.justice.vic.gov.au/record/15111431/File/document2'\r\n};\r\n\r\nexport async function emailMaker(data: { today: string; todayplus14: string; emailTo: any; EmailAddress: undefined; }, parameters: [any, keyof typeof templateMap, ...any[]]) {\r\n\r\n\r\n\tlet templateUrl;\r\n\tif (parameters[1] === 'MOU') {\r\n\t\ttemplateUrl = parameters[2] === 'Agency FR Granted' ?\r\n\t\t\ttemplateMap.MOU['Agency FR Granted'] :\r\n\t\t\ttemplateMap.MOU.default;\r\n\t} else {\r\n\t\ttemplateUrl = templateMap[parameters[1]];\r\n\t}\r\n\r\n\tconst res = await fetch(templateUrl);\r\n\r\n\tlet template = await res.text();\r\n\tdata.today = getDates().today\r\n\tdata.todayplus14 = getDates().todayplus14\r\n\tdata.emailTo = data.EmailAddress !== undefined ? data.EmailAddress : \"None\";\r\n\tlet result = template.split('----boundary_text_string');\r\n\tmarked.setOptions({ 'breaks': true, \"gfm\": true });\r\n\tresult[1] = await marked.parse(result[1]);\r\n\ttemplate = result.join('----boundary_text_string \\n');\r\n\ttemplate = template.replace('<p>Content-Type: text/html</p>', 'Content-Type: text/html \\n');\r\n\tdownloadEmail(template, parameters, data);\r\n}\r\n\r\nfunction readFileAsync(blob: Blob): Promise<string> {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tlet reader = new FileReader();\r\n\r\n\t\treader.onload = () => {\r\n\t\t\tresolve(reader.result as string); // Type assertion here\r\n\t\t};\r\n\r\n\t\treader.onerror = reject;\r\n\r\n\t\treader.readAsDataURL(blob);\r\n\t});\r\n}\r\n/* \r\nSqrl.helpers.define('addAttachment', async function (str) {\r\n\tlet out: string\r\n\tlet res = await fetch('https://trimapi.justice.vic.gov.au/record/' + str.params[0] + '/File/document2');\r\n\tlet blob = await res.blob();\r\n\r\n\tout = await readFileAsync(blob);\r\n\tout = out.replace('data:application/octet-stream;base64,', '')\r\n\treturn out\r\n}) */\r\n\r\nexport { };\r\n\r\ndeclare global {\r\n\tinterface Date {\r\n\t\taddDays(days: number): Date;\r\n\t}\r\n}\r\n\r\nDate.prototype.addDays = function (days: number) {\r\n\tvar date = new Date(this.valueOf());\r\n\tdate.setDate(date.getDate() + days);\r\n\treturn date;\r\n}\r\n\r\nexport function getDates() {\r\n\tvar monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\r\n\tconst todayDate = new Date();\r\n\tvar dd = String(todayDate.getDate()).padStart(2, '0');\r\n\tvar mm = monthNames[todayDate.getMonth()];\r\n\tvar yyyy = todayDate.getFullYear();\r\n\tvar today: string = dd + ' ' + mm + ' ' + yyyy;\r\n\tvar todayplus28 = new Date().addDays(28);\r\n\tvar dd28 = String(todayplus28.getDate()).padStart(2, '0');\r\n\tvar mm28 = monthNames[todayplus28.getMonth()];\r\n\tvar yyyy28 = todayplus28.getFullYear();\r\n\tvar todayplus21 = new Date().addDays(21);\r\n\tvar dd21 = String(todayplus21.getDate()).padStart(2, '0');\r\n\tvar mm21 = monthNames[todayplus21.getMonth()];\r\n\tvar yyyy21 = todayplus21.getFullYear();\r\n\tvar todayplus14 = new Date().addDays(14);\r\n\tvar dd14 = String(todayplus14.getDate()).padStart(2, '0');\r\n\tvar mm14 = monthNames[todayplus14.getMonth()];\r\n\tvar yyyy14 = todayplus14.getFullYear();\r\n\treturn { \"today\": today, \"todayplus14\": dd14 + ' ' + mm14 + ' ' + yyyy14, \"todayplus28\": dd28 + ' ' + mm28 + ' ' + yyyy28, \"todayplus21\": dd21 + ' ' + mm21 + ' ' + yyyy21 };\r\n}\r\n\r\nfunction downloadEmail(emlContent: string, parameters: [any, \"Report Needed\" | \"MOU\" | \"Unable to Contact Applicant\" | \"FVS Further Information Required\" | \"Further Information Required\", ...any[]] | string[], data: { today?: string; todayplus14?: string; emailTo?: any; EmailAddress?: undefined; First_Name?: any; Last_Name?: any; enforcename?: any; }) {\r\n\tvar encodedUri = encodeURI(emlContent); //encode spaces etc like a url\r\n\tencodedUri = encodedUri.replace(/#/g, '%23')\r\n\tvar a = document.createElement('a'); //make a link in document\r\n\tvar linkText = document.createTextNode(\"fileLink\");\r\n\ta.appendChild(linkText);\r\n\ta.href = encodedUri;\r\n\ta.id = 'fileLink';\r\n\tif (parameters[1] !== 'MOU') {\r\n\t\ta.download = data.First_Name + \" \" + data.Last_Name + ' - ' + parameters[1] + '.eml';\r\n\t} else {\r\n\t\ta.download = data.First_Name + \" \" + data.Last_Name + ' - ' + data.enforcename + '.eml';\r\n\t}\r\n\ta.style = \"display:none;\"; //hidden link\r\n\tdocument.body.appendChild(a);\r\n\tconst fileLink = document.getElementById('fileLink');\r\n\tif (fileLink) {\r\n\t\tfileLink.click(); //click the link\r\n\t}\r\n\ta.remove();\r\n}","// @ts-nocheck\r\n\r\nlet expressions = require('angular-expressions');\r\n\r\nexport function downloadLetter(address, properties) {\r\n    let addressArray = address.split(\",\");\r\n\r\n    if (addressArray.length > 5) {\r\n        addressArray[1] = `${addressArray[0]}${addressArray[1]}`;\r\n        addressArray.shift();\r\n    }\r\n\r\n    let l = {\r\n        \"provable\": [],\r\n        \"courtFines\": [],\r\n        \"nonProvable\": [],\r\n        \"zeroBalance\": [],\r\n        \"dateOfBankruptcy\": toDate(properties.dateOfBankruptcy).toLocaleString('en-au', { day: 'numeric', month: 'long', year: 'numeric' }),\r\n        \"bankruptcynotificationdate\": toDate(document.getElementById('noteDate').value).toLocaleString('en-au', { day: 'numeric', month: 'long', year: 'numeric' }),\r\n        \"First_Name\": properties.firstName,\r\n        \"Last_Name\": properties.lastName,\r\n        \"Address_1\": addressArray[0].trim(),\r\n        \"Town\": addressArray[1].trim(),\r\n        \"State\": addressArray[2].trim(),\r\n        \"Post_Code\": addressArray[3].trim(),\r\n        \"Debtor_ID\": properties.debtorid\r\n    }\r\n    let reduced = properties.agencies.reduce((obj, item) => (obj[item.key] = item.value, obj), {});\r\n\r\n    properties.allObligations.rows({ selected: true }).every(function (rowIdx, tableLoop, rowLoop) {\r\n        let data = this.data();\r\n\r\n        const types = [\"1A\", \"1B\", \"1C\", \"2A\"];\r\n        const statuses = [\"WARRNT\", \"CHLGLOG\", \"NFDP\", \"SELDEA\"];\r\n        if (String(data.Offence) === \"0000\") {\r\n            properties.courtDetails;\r\n            data.hearingDate = properties.courtDetails[data.NoticeNumber].hearingDate\r\n            data.courtLocation = properties.courtDetails[data.NoticeNumber].courtLocation\r\n            data.CaseRef = properties.courtDetails[data.NoticeNumber].CaseRef\r\n        }\r\n        data.agency = reduced[data.NoticeNumber];\r\n        let bd = moment(properties.dateOfBankruptcy, \"YYYY-MM-DD\")\r\n        let td = moment(data.OffenceDate, \"DD/MM/YYYY\")\r\n\r\n        let balance = Number(data.BalanceOutstanding.replace(/[^0-9.-]+/g, \"\"));\r\n\r\n        (balance <= 0) &&\r\n            (l.zeroBalance.push(data)) ||\r\n            (bd.isAfter(td)) &&\r\n            (types.some(type => data.InputType === type)) &&\r\n            (statuses.some(status => data.NoticeStatusPreviousStatus.includes(status))) &&\r\n            (l.provable.push(data)) ||\r\n            (data.Offence === \"0000\") &&\r\n            (l.courtFines.push(data)) ||\r\n            (statuses.some(status => data.NoticeStatusPreviousStatus.includes(status))) &&\r\n            (l.nonProvable.push(data));\r\n\r\n    })\r\n    properties.filename = `${titleCase(properties.firstName)} ${titleCase(properties.lastName)} - Bankruptcy Confirmation`\r\n    backgroundLetterMaker(l, properties, \"https://trimwebdrawer.justice.vic.gov.au/record/13930494/File/document\")\r\n}\r\n\r\n\r\n\r\n\r\nfunction angularParser(tag) {\r\n\r\n    if (tag === '.') {\r\n        return {\r\n            get: function (s) { return s; }\r\n        }\r\n    }\r\n\r\n    /*  if (tag.includes('%')) {\r\n        return {\r\n            'get': function (scope) { return scope[tag] }\r\n        }\r\n    }*/\r\n\r\n    const expr = expressions.compile(tag.replace(/(||)/g, \"'\"));\r\n\r\n    return {\r\n        get: function (s) {\r\n            return expr(s);\r\n        }\r\n    }\r\n}\r\n\r\nasync function backgroundLetterMaker(letterData, properties, letterTemplateURL) {\r\n    const letterTemplate = await loadLetter(letterTemplateURL)\r\n    /* Create a letter for each of the objects in letterData */\r\n    const letter = makeLetter(letterData, letterTemplate, properties.filename)\r\n}\r\n\r\nexport function makeLetter(content, letterTemplate, filename, imageModule) {\r\n\r\n    var zip = new PizZip(letterTemplate);\r\n    var doc = new window.Docxtemplater().loadZip(zip)\r\n    if (imageModule) {\r\n        doc.attachModule(imageModule);\r\n    }\r\n    doc.setOptions({\r\n        parser: angularParser\r\n    })\r\n    console.log(content)\r\n    doc.setData(content);\r\n\r\n    try {\r\n        // render the document (replace all occurences of {first_name} by John, {last_name} by Doe, ...)\r\n        doc.render()\r\n    }\r\n    catch (error) {\r\n        var e = {\r\n            message: error.message,\r\n            name: error.name,\r\n            stack: error.stack,\r\n            properties: error.properties,\r\n        }\r\n        // console.log(JSON.stringify({ error: e }));\r\n        // The error thrown here contains additional information when logged with JSON.stringify (it contains a property object).\r\n        throw error;\r\n    }\r\n    var out = doc.getZip().generate({\r\n        type: \"blob\",\r\n        mimeType: \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\r\n    }) //Output the document using Data-URI    \r\n    saveAs(out, filename + \".docx\")\r\n}\r\n\r\nfunction loadLetter(url) {\r\n    return new Promise((resolve, reject) => {\r\n        JSZipUtils.getBinaryContent(url, function (err, data) {\r\n            if (err) {\r\n                throw err; // or handle err\r\n            }\r\n            data = resolve(data);\r\n            return data;\r\n        });\r\n    });\r\n}\r\n\r\nconst toDate = (dateStr = \"2000-01-01\") => {\r\n    const [day, month, year] = dateStr.split(\"-\").reverse()\r\n    return new Date(year, month - 1, day)\r\n}\r\n\r\nfunction titleCase(string) {\r\n    var sentence = string.trim().toLowerCase().split(\" \");\r\n    for (var i = 0; i < sentence.length; i++) {\r\n        sentence[i] = sentence[i][0].toUpperCase() + sentence[i].slice(1);\r\n    }\r\n    return sentence.join(\" \");\r\n}\r\n","import { DataParams } from \"./VIEWsubmit.js\";\r\nimport { emailMaker, getDates } from \"./emailmaker\";\r\n\r\n// Declare external global libraries/variables if not properly typed via imports/types\r\ndeclare const JSZipUtils: {\r\n    getBinaryContent(url: string, callback: (err: Error | null, data: ArrayBuffer) => void): void;\r\n};\r\n\r\n// Import types or functions from other modules\r\n// Assuming VIEWsubmit takes config and properties and returns a Promise\r\nimport VIEWsubmit from \"./VIEWsubmit\"; // Adjust if it has a default export or named exports\r\n\r\n// Assuming makeLetter takes data, template buffer, and filename\r\nimport { makeLetter } from './genLetter-module'; // Adjust if default export\r\ntype MakeLetterType = (data: any, template: ArrayBuffer, filename: string) => void;\r\nimport { Data } from \"pizzip\"\r\ntype FetchRetryTimeoutType = (url: string, options?: RequestInit) => Promise<Response>;\r\n\r\n// --- Interfaces and Type Definitions ---\r\n\r\ninterface ObligationRowData {\r\n    \"Notice Number\": string;\r\n    \"Input Type\": string; // e.g., \"1A\", \"1C\"\r\n    \"Balance Outstanding\": string; // e.g., \"$123.45\"\r\n    \"Infringement No.\": string;\r\n    \"Offence\": string;\r\n    \"Offence Date\": string; // e.g., \"DD/MM/YYYY\"\r\n    \"Issued\": string; // e.g., \"DD/MM/YYYY\"\r\n    \"Notice Status/Previous Status\": string; // e.g., \"CHLGLOG\", \"SELDEA\", \"WARRNT\", \"NFDP\"\r\n    \"Due Date\": string; // e.g., \"DD/MM/YYYY\"\r\n    // Properties added later\r\n    \"Obligation\"?: string;\r\n    \"Balance_Outstanding\"?: string;\r\n    \"Infringement\"?: string;\r\n    \"OffenceDate\"?: string;\r\n    \"IssueDate\"?: string;\r\n    \"altname\"?: string; // Agency Code/Name\r\n    \"NoticeStatus\"?: string;\r\n    \"ProgressionDate\"?: string;\r\n    \"NFDlapsed\"?: boolean;\r\n    \"Challenge\"?: string; // Added from reviewTableData\r\n}\r\n\r\ninterface AgencyInfo {\r\n    key: string; // Notice Number\r\n    value: string; // Agency Code/Name\r\n}\r\n\r\ninterface AddressInfo {\r\n    Address_1: string;\r\n    Town: string;\r\n    State: string;\r\n    Post_Code?: string;\r\n}\r\n\r\ninterface TemplateMeta {\r\n    kind: 'Agency' | 'Debtor';\r\n    letter: string; // Letter name, e.g., 'Agency Enforcement Cancelled'\r\n    template: Promise<ArrayBuffer>; // Promise resolving to the template binary data\r\n}\r\n\r\ninterface Properties {\r\n    obligationRows: ObligationRowData[];\r\n    source: string; // e.g., \"finesvictoria\"\r\n    agency: boolean; // Flag indicating if agency letters are needed\r\n    letters: string[]; // Array of letter names, e.g., ['Enforcement Confirmed']\r\n    extended: boolean; // Flag for extended processing?\r\n    SharePoint: boolean; // Flag to load templates from SharePoint\r\n    // Properties added during processing\r\n    agencies?: AgencyInfo[];\r\n    obligationsCountFixed?: number;\r\n    obligationsCount?: number;\r\n    agenciesList?: Promise<Response>; // Promise for agency address list fetch\r\n    reviewList?: Promise<Response>; // Promise for review list fetch\r\n    templates?: TemplateMeta[];\r\n    DebtorId?: string;\r\n    lastName?: string;\r\n    firstName?: string;\r\n    companyName?: string;\r\n    Is_Company?: boolean;\r\n    Address?: AddressInfo;\r\n    challengeType?: string; // Added from getChallenge group\r\n    letterData?: any[]; // Array of data objects for makeLetter\r\n}\r\n\r\n// Type for the message received by the listener\r\n// Using 'any' for indices as the structure isn't strictly defined by an interface in the JS\r\n// A more robust approach would be to send an object with named properties instead of an array.\r\ntype IncomingMessage = [\r\n    any, // 0: Unknown\r\n    string, // 1: Some string identifier (checked for 'Bulk', 'Export')\r\n    any, // 2: Unknown\r\n    any, // 3: Unknown\r\n    boolean, // 4: Boolean flag (checked for false)\r\n    string, // 5: source\r\n    ObligationRowData[], // 6: obligationRows\r\n    boolean, // 7: agency flag\r\n    string[], // 8: letters array\r\n    boolean, // 9: extended flag\r\n    boolean // 10: SharePoint flag\r\n];\r\n\r\n// Type for parsed table data (flexible key-value pairs)\r\ntype ParsedTableRow = Record<string, string>;\r\n\r\n// Type for the structure returned by letterGen\r\ninterface SubmitStep {\r\n    url?: string | ((parsedDocument: Document, properties: Properties) => string);\r\n    urlParams?: (parsedDocument: Document | null, set: any, properties: Properties) => void | Record<string, any> | ((parsedDocument: Document | null, dynamicParams: any) => Record<string, any>);\r\n    after?: (parsedDocument: Document | null, properties: Properties) => void;\r\n    group?: string; // Identifier for groupRepeats\r\n    clearVIEWFormData?: boolean;\r\n    // Allow 'this' context modification for URL\r\n    [key: string]: any; // Allow dynamic properties like 'this.url' assignment\r\n}\r\n\r\ninterface LetterGenConfig extends DataParams {\r\n    groupRepeats?: Record<string, () => Record<string, string>[]>;\r\n}\r\n\r\n// Type for Chrome storage local data\r\ninterface ChromeStorageData {\r\n    obligationsCount?: number;\r\n    obligationsCountFixed?: number;\r\n    value?: Record<string, any[]>; // Structure from getAppData\r\n    userName?: string;\r\n}\r\n\r\ninterface LetterTypeDef {\r\n    filename: string;\r\n    Props?: string[];\r\n}\r\n\r\n// --- Global State ---\r\nlet running: boolean = false; // Simple lock state\r\n\r\n// --- Chrome Message Listener ---\r\nchrome.runtime.onMessage.addListener(\r\n    (message: IncomingMessage, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void): boolean | undefined => {\r\n        // Basic check for message structure - consider adding more validation\r\n        if (!Array.isArray(message) || message.length < 11) {\r\n            console.warn(\"Received unexpected message format:\", message);\r\n            return;\r\n        }\r\n\r\n        const source = message[5];\r\n        const expectedUrlPart = `https://${source}.view.civicacloud.com.au/Traffic/Debtors/Forms/DebtorObligations`.toUpperCase();\r\n\r\n        if (sender.url && sender.url.toUpperCase().includes(expectedUrlPart) &&\r\n            !message[1].includes('Bulk') && !message[1].includes('Export') &&\r\n            message[4] === false) {\r\n\r\n            const properties: Partial<Properties> = {}; // Start with partial, will be filled\r\n            properties.obligationRows = message[6];\r\n            properties.source = message[5];\r\n            properties.agency = message[7];\r\n            properties.letters = message[8];\r\n            properties.extended = message[9];\r\n            properties.SharePoint = message[10];\r\n\r\n            // Ensure all required properties are present before launching\r\n            if (properties.obligationRows && properties.source && properties.letters) {\r\n                launch(properties as Properties)\r\n                    .then(() => {\r\n                        console.log(\"Launch completed successfully.\");\r\n                        // sendResponse({ status: \"success\" }); // Optional: respond if needed\r\n                    })\r\n                    .catch(error => {\r\n                        console.error(\"Error during launch:\", error);\r\n                        // sendResponse({ status: \"error\", message: error instanceof Error ? error.message : String(error) }); // Optional: respond on error\r\n                        // Re-throw if necessary for higher-level handlers\r\n                        // throw error;\r\n                    });\r\n                return true; // Indicates that sendResponse will be called asynchronously (optional)\r\n            } else {\r\n                console.error(\"Missing required properties in message:\", message);\r\n            }\r\n        }\r\n        // Return false or undefined if not handling the message or not responding asynchronously\r\n        return undefined;\r\n    }\r\n);\r\n\r\n// --- Main Launch Function ---\r\nasync function launch(properties: Properties): Promise<void> {\r\n    try {\r\n        // Assuming VIEWsubmit matches the inferred type\r\n        await (VIEWsubmit)({}, 0, undefined, letterGen(properties), properties);\r\n    } catch (err) {\r\n        const errorMessage = err instanceof Error ? err.message : String(err);\r\n        if (errorMessage !== 'Scraper already running') {\r\n            running = false; // Reset lock only if it's not the 'already running' error\r\n        }\r\n        // Re-throw the original error to propagate it\r\n        throw err;\r\n    }\r\n}\r\n\r\n// --- Letter Generation Configuration ---\r\nfunction letterGen(properties: Properties): LetterGenConfig {\r\n    if (running === true) {\r\n        throw new Error('Scraper already running'); // Throw an actual Error object\r\n    }\r\n    running = true;\r\n\r\n    return {\r\n        groupRepeats: {\r\n            \"obligationsGroup\": (): Record<string, string>[] => {\r\n                properties.agencies = properties.agencies ?? []; // Initialize if undefined\r\n                let paramArray: Record<string, string>[] = [];\r\n                if (properties.agency || properties.extended) {\r\n                    properties.obligationRows.forEach(data => {\r\n                        const params: Record<string, string> = {};\r\n                        if (data[\"Input Type\"]?.includes('1A')) {\r\n                            properties.agencies!.push({ key: data[\"Notice Number\"], value: \"TRAFFIC CAMERA OFFICE\" });\r\n                        } else if (data[\"Input Type\"]?.includes('1C')) {\r\n                            properties.agencies!.push({ key: data[\"Notice Number\"], value: \"VICTORIA POLICE TOLL ENFORCEMENT OFFICE\" });\r\n                        } else {\r\n                            params[\"txtNoticeNo\"] = data[\"Notice Number\"];\r\n                            paramArray.push(params);\r\n                        }\r\n                    });\r\n                }\r\n                properties.obligationsCountFixed = paramArray.length;\r\n                properties.obligationsCount = paramArray.length;\r\n                return paramArray;\r\n            },\r\n            \"getChallenge\": (): Record<string, string>[] => {\r\n                const paramArray: Record<string, string>[] = [];\r\n                // Ensure obligationRows exists and has at least one element\r\n                if (properties.obligationRows?.[0]?.['Notice Status/Previous Status'] &&\r\n                    !properties.obligationRows[0]['Notice Status/Previous Status'].includes('CHLGLOG')) {\r\n                    paramArray.push({ \"txtNoticeNo\": properties.obligationRows[0][\"Notice Number\"] });\r\n                }\r\n                return paramArray;\r\n            }\r\n        },\r\n        submit: [{\r\n            url: `https://${properties.source}.view.civicacloud.com.au/Traffic/Debtors/Forms/DebtorAddresses.aspx`,\r\n            urlParams: (parsedDocument: Document | null, set: any, props: Properties): void => {\r\n                // Ensure chrome storage types are correct\r\n                const storageData: ChromeStorageData = { 'obligationsCount': 10, \"obligationsCountFixed\": 10 };\r\n                chrome.storage.local.set(storageData);\r\n\r\n                // Assuming fetchRetryTimeout matches the inferred type\r\n                props.agenciesList = (fetch as FetchRetryTimeoutType)('https://vicgov.sharepoint.com/:u:/s/msteams_3af44a/ETiKQS5uTzxHnTmAV6Zpl9oBvhNZexZFmJrJxLNZLD6L4A?download=1');\r\n                props.reviewList = (fetch as FetchRetryTimeoutType)(`https://${props.source}.view.civicacloud.com.au/Traffic/Debtors/Forms/DebtorDecisionReview.aspx`);\r\n                props.templates = props.letters.map((letter): TemplateMeta => {\r\n                    const urlKey = letter as keyof typeof letterURL; // Type assertion\r\n                    const trimRecordId = letterURL[urlKey];\r\n                    if (!trimRecordId) {\r\n                        console.error(`No URL found for letter type: ${letter}`);\r\n                        // Handle error appropriately - maybe return a dummy template promise?\r\n                        throw new Error(`Missing URL configuration for letter: ${letter}`);\r\n                    }\r\n                    const letterTemplateURL = `https://trimapi.justice.vic.gov.au/record/${trimRecordId}/File/document2`;\r\n                    // Assuming the SharePoint URL structure is consistent and uses the same ID\r\n                    const SharePointletterTemplateURL = `https://vicgov-my.sharepoint.com/:w:/g/personal/adrian_zafir_justice_vic_gov_au/${trimRecordId}?download=1`;\r\n\r\n                    return {\r\n                        \"kind\": letter === 'Agency Enforcement Cancelled' ||\r\n                            letter === 'Agency Fee Removal' ||\r\n                            letter === 'FVS Eligible Agency' ||\r\n                            letter === 'Agency FR Granted' ||\r\n                            letter === 'Agency Enforcement Cancelled Updated' || // Ensure this is in letterURL\r\n                            letter === \"Notice of Deregistration\" ? 'Agency' : 'Debtor',\r\n                        \"letter\": letter,\r\n                        \"template\": props.SharePoint === true ? loadLetter(SharePointletterTemplateURL) : loadLetter(letterTemplateURL)\r\n                    };\r\n                });\r\n            },\r\n            after: (parsedDocument: Document | undefined): void => {\r\n                if (!parsedDocument) return; // Guard against null document\r\n\r\n                // Use optional chaining and nullish coalescing for safer access\r\n                properties.DebtorId = (parsedDocument.querySelector(\"#DebtorDetailsCtrl_DebtorIdSearch\") as HTMLInputElement)?.value?.trim() ?? '';\r\n                properties.lastName = parsedDocument.querySelector(\"#DebtorDetailsCtrl_surnameTxt\")?.textContent?.trim() ?? '';\r\n                properties.firstName = parsedDocument.querySelector(\"#DebtorDetailsCtrl_firstnameTxt\")?.textContent?.trim() ?? '';\r\n                properties.companyName = parsedDocument.querySelector(\"#DebtorDetailsCtrl_companyNameTxt\")?.textContent?.trim() ?? '';\r\n                properties.Is_Company = !!properties.companyName; // Simpler boolean check\r\n\r\n                const addressTable = parsedDocument.querySelector(\"#DebtorAddressesCtrl_gridDebtorAddresses_tblData\") as HTMLTableElement | null;\r\n                if (!addressTable) {\r\n                    console.warn(\"Address table not found.\");\r\n                    properties.Address = { Address_1: \"\", Town: \"\", State: \"\", Post_Code: \"\" }; // Default empty address\r\n                    return;\r\n                }\r\n\r\n                let addressTableData = parseTable(addressTable);\r\n                let addressParts: string[] = []; // Initialize as empty array\r\n\r\n                addressTableData = addressTableData.filter(row => row[\"Best Address\"] === \"Y\");\r\n\r\n                const addressObject = convertArrayToObject(addressTableData, \"Type\");\r\n\r\n                for (const priority of addressPriority) {\r\n                    if (addressObject[priority]?.Address) { // Check if priority exists and has Address\r\n                        addressParts = addressObject[priority].Address.split(\",\");\r\n                        addressParts.push(addressObject[priority].Postcode ?? ''); // Use nullish coalescing for postcode\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Clean up address parts (ensure strings before trimming)\r\n                addressParts = addressParts.map(part => String(part || '').trim());\r\n\r\n                // Handle unit numbers etc. combined with street name\r\n                if (addressParts.length > 0 && addressParts.length > 4) { // Check length before accessing index 1\r\n                    addressParts[1] = `${addressParts[0]} ${addressParts[1]}`; // Add space\r\n                    addressParts.shift();\r\n                }\r\n\r\n                properties.Address = {\r\n                    \"Address_1\": addressParts[0] ?? '', // Provide defaults\r\n                    \"Town\": addressParts[1] ?? '',\r\n                    \"State\": addressParts[2] ?? '',\r\n                    \"Post_Code\": addressParts[3] ?? undefined\r\n                };\r\n            }\r\n        }, {\r\n            group: \"obligationsGroup\",\r\n            urlParams: function (this: SubmitStep, parsedDocument: Document | undefined, dynamicParams: Record<string, string>): Record<string, any> {\r\n                // Modify the URL on the 'this' context (the step object)\r\n                this.url = `https://${properties.source}.view.civicacloud.com.au/Traffic/Notices/forms/NoticesManagement/SearchNotice.aspx?&NoticeNo=${dynamicParams.txtNoticeNo}`;\r\n                return {}; // Return empty object as params are in URL\r\n            },\r\n            after: (parsedDocument: Document | undefined): void => {\r\n                if (!parsedDocument || !properties.obligationsCountFixed || properties.obligationsCount === undefined) return;\r\n\r\n                const progress = ((properties.obligationsCountFixed - properties.obligationsCount + 1) / properties.obligationsCountFixed) * 10; // Correct progress calculation\r\n                properties.obligationsCount--;\r\n                const storageData: ChromeStorageData = { 'obligationsCount': progress, \"obligationsCountFixed\": 10 }; // Consider if fixed should be dynamic\r\n                chrome.storage.local.set(storageData);\r\n\r\n                const noticeNo = (parsedDocument.getElementById(\"NoticeInfo_txtNoticeNo\") as HTMLInputElement)?.value;\r\n                const agencyCode = parsedDocument.getElementById(\"NoticeInfo_lblAgencyCode\")?.textContent;\r\n\r\n                if (noticeNo && agencyCode) {\r\n                    properties.agencies = properties.agencies ?? [];\r\n                    properties.agencies.push({ key: noticeNo, value: agencyCode });\r\n                } else {\r\n                    console.warn(\"Could not extract notice number or agency code.\");\r\n                }\r\n            },\r\n            clearVIEWFormData: true\r\n        }, {\r\n            group: \"getChallenge\",\r\n            urlParams: function (this: SubmitStep, parsedDocument: Document | undefined, dynamicParams: Record<string, string>): Record<string, any> {\r\n                this.url = `https://${properties.source}.view.civicacloud.com.au/Traffic/Notices/forms/NoticesManagement/SearchNotice.aspx?&NoticeNo=${dynamicParams.txtNoticeNo}`;\r\n                return {};\r\n            },\r\n            clearVIEWFormData: true\r\n        }, {\r\n            group: \"getChallenge\",\r\n            url: `https://${properties.source}.view.civicacloud.com.au/Traffic/Notices/Forms/NoticesManagement/NoticeChallengeHistory.aspx`,\r\n            after: (parsedDocument: Document | undefined): void => {\r\n                if (!parsedDocument) return;\r\n                const challengeText = parsedDocument.querySelector(\"#lblChallengeCodeVal\")?.textContent ?? '';\r\n                const match = challengeText.match(/Enforcement - (.*)/);\r\n                properties.challengeType = match ? match[1] : 'No Challenge Logged';\r\n            },\r\n            clearVIEWFormData: true\r\n        }\r\n        ],\r\n        afterAction: async (doc?, props?): Promise<void> => {\r\n            // Ensure required promises exist before proceeding\r\n            if (!props || !props.agenciesList || !props.reviewList || !props.templates) {\r\n                console.error(\"Prerequisite data (agenciesList, reviewList, templates) missing in afterAction.\");\r\n                running = false; // Reset lock on error\r\n                throw new Error(\"Missing prerequisite data for afterAction.\");\r\n            }\r\n\r\n            // Combine agency info into a lookup object\r\n            const agencyLookup: Record<string, string> = (props.agencies ?? []).reduce((obj: { [x: string]: any; }, item: { key: string | number; value: any; }) => {\r\n                obj[item.key] = item.value;\r\n                return obj;\r\n            }, {} as Record<string, string>);\r\n\r\n            try {\r\n                // Resolve all promises concurrently\r\n                const results = await Promise.all([\r\n                    props.agenciesList.then((response: { json: () => any; }) => response.json()), // Assuming JSON response\r\n                    props.reviewList.then((response: { text: () => any; }) => response.text()),   // Assuming text/HTML response\r\n                    // Resolve template promises (already initiated)\r\n                    ...props.templates.map((t: { template: any; }) => t.template)\r\n                ]);\r\n\r\n                const agenciesListData = results[0]; // Type this if structure is known (e.g., { addresses: any[] })\r\n                const reviewListHtml = results[1] as string;\r\n                const templateBuffers = results.slice(2) as ArrayBuffer[];\r\n\r\n                // Assign resolved templates back to properties.templates\r\n                props.templates.forEach((templateMeta: { template: Promise<ArrayBuffer>; }, index: number) => {\r\n                    // Re-wrap in a resolved promise if needed elsewhere, or just store buffer\r\n                    templateMeta.template = Promise.resolve(templateBuffers[index]);\r\n                });\r\n\r\n                // Process obligation rows\r\n                props.obligationRows = props.obligationRows.map((row: ObligationRowData): ObligationRowData => {\r\n                    const noticeNumber = row['Notice Number'];\r\n                    const dueDate = row['Due Date'];\r\n                    const noticeStatus = row['Notice Status/Previous Status'];\r\n\r\n                    let isLapsed = false;\r\n                    if (dueDate) {\r\n                        const dateParts = dueDate.split(\"/\");\r\n                        if (dateParts.length === 3) {\r\n                            // Check date format before creating Date object\r\n                            const year = parseInt(dateParts[2], 10);\r\n                            const month = parseInt(dateParts[1], 10) - 1; // Month is 0-indexed\r\n                            const day = parseInt(dateParts[0], 10);\r\n                            if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {\r\n                                isLapsed = new Date(year, month, day).getTime() < Date.now();\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return {\r\n                        ...row, // Spread existing row data\r\n                        Obligation: noticeNumber,\r\n                        Balance_Outstanding: row['Balance Outstanding'],\r\n                        Infringement: row['Infringement No.'],\r\n                        Offence: row['Offence'],\r\n                        OffenceDate: row['Offence Date'],\r\n                        IssueDate: row['Issued'],\r\n                        altname: agencyLookup[noticeNumber] ?? 'Unknown Agency', // Use lookup\r\n                        NoticeStatus: noticeStatus,\r\n                        ProgressionDate: dueDate,\r\n                        NFDlapsed: noticeStatus === 'SELDEA' || noticeStatus === 'WARRNT' || (isLapsed && noticeStatus === 'NFDP')\r\n                    };\r\n                });\r\n\r\n                // Parse review list HTML\r\n                const parser = new DOMParser();\r\n                const reviewDoc = parser.parseFromString(reviewListHtml, 'text/html');\r\n                const reviewTable = reviewDoc.querySelector(\"#DebtorDecisionCtrl_DebtorNoticesTable_tblData\") as HTMLTableElement | null;\r\n\r\n                if (reviewTable) {\r\n                    const reviewTableData = parseTable(reviewTable);\r\n                    reviewTableData.forEach(reviewdata => {\r\n                        const challengeCode = reviewdata['Challenge Code'] as keyof typeof challengeList;\r\n                        const ob = props.obligationRows.find((data: { Obligation: string; }) => reviewdata['Notice Number'] == data.Obligation);\r\n                        if (ob) {\r\n                            ob.Challenge = challengeList[challengeCode] ?? 'Unknown Challenge'; // Use lookup\r\n                        }\r\n                    });\r\n                } else {\r\n                    console.warn(\"Review table not found in fetched HTML.\");\r\n                }\r\n\r\n                // Prepare base letter data\r\n                const baseLetterData: any = { // Use 'any' for flexibility initially, refine if possible\r\n                    \"First_Name\": toTitleCaseHypen(toTitleCase(props.firstName ?? '')).trim().split(\" \")[0],\r\n                    \"Last_Name\": toTitleCaseHypen(toTitleCase(props.lastName ?? '')).trim(),\r\n                    \"Company_Name\": props.Is_Company ? toTitleCase(props.companyName ?? '').trim() : undefined,\r\n                    \"Is_Company\": props.Is_Company ?? false,\r\n                    \"Address_1\": toTitleCase(props.Address?.Address_1 ?? '').trim(),\r\n                    \"Town\": props.Address?.Town ?? '',\r\n                    \"Town2\": toTitleCase(props.Address?.Town ?? ''), // Duplicate?\r\n                    \"State\": props.Address?.State ?? '',\r\n                    \"Post_Code\": props.Address?.Post_Code,\r\n                    \"Debtor_ID\": props.DebtorId,\r\n                    \"Challenge\": props.obligationRows?.[0]?.Challenge ?? props.challengeType ?? 'No Challenge Logged',\r\n                    \"UserID\": await getData('userName') // Assuming getData returns Promise<string | undefined>\r\n                };\r\n\r\n                baseLetterData.OnlyNFDLapsed = !(props.obligationRows?.some((row: { NFDlapsed: boolean; }) => row.NFDlapsed === false) ?? false);\r\n\r\n                // Enhance base data with AppData\r\n                await getAppData(baseLetterData); // Modifies baseLetterData in place\r\n\r\n                // Address formatting (make safer)\r\n                const replacements: [RegExp, string][] = [\r\n                    [/ Gr$/i, \" Grove\"], [/ St$/i, \" Street\"], [/ Dr$/i, \" Drive\"], [/ Ct$/i, \" Court\"],\r\n                    [/ Rd$/i, \" Road\"], [/ Ave?$/i, \" Avenue\"], [/ Cre?s?$/i, \" Crescent\"], [/ Pl$/i, \" Place\"],\r\n                    [/ Tce$/i, \" Terrace\"], [/ Bvd$/i, \" Boulevard\"], [/ Cl$/i, \" Close\"], [/ Cir$/i, \" Circle\"],\r\n                    [/ Pde$/i, \" Parade\"], [/ Cct$/i, \" Circuit\"], [/ Wy$/i, \" Way\"], [/ Esp$/i, \" Esplanade\"],\r\n                    [/ Sq$/i, \" Square\"], [/ Hwy$/i, \" Highway\"], [/^Po /i, \"PO \"]\r\n                ];\r\n                let address1 = baseLetterData.Address_1 || '';\r\n                replacements.forEach(([regex, replacement]) => {\r\n                    address1 = address1.replace(regex, replacement);\r\n                });\r\n                baseLetterData.Address_1 = address1;\r\n\r\n\r\n                // Prepare final letter data array\r\n                props.letterData = [];\r\n\r\n                if (props.agency && agenciesListData?.addresses) { // Check agenciesListData structure\r\n                    let groupedByAgency = groupBy(props.obligationRows ?? [], 'altname');\r\n                    // Ensure mergeById handles potential missing data gracefully\r\n                    groupedByAgency = mergeById(groupedByAgency, agenciesListData.addresses, \"altname\", \"altname\"); // Assuming 'altname' matches key in addresses\r\n                    props.letterData.push(...groupedByAgency.map((item: any) => ({ ...item, ...baseLetterData, kind: \"Agency\" })));\r\n                }\r\n\r\n                if (!props.letters.includes(\"Notice of Deregistration\")) { // Check if debtor letter is needed\r\n                    // Ensure 'a' property is expected by downstream consumers\r\n                    props.letterData.push({ ...baseLetterData, a: props.obligationRows, kind: \"Debtor\" });\r\n                }\r\n\r\n                const storageUpdate: ChromeStorageData = { 'obligationsCount': 0, \"obligationsCountFixed\": 10 };\r\n                chrome.storage.local.set(storageUpdate);\r\n\r\n                // Generate letters\r\n                if (!props.letterData || props.letterData.length === 0) {\r\n                    console.log(\"No letter data generated.\");\r\n                    running = false; // Reset lock\r\n                    return;\r\n                }\r\n\r\n                for (const data of props.letterData) {\r\n                    // Determine letter type and find corresponding template meta\r\n                    const userId = String(data.UserID ?? 'UnknownUser'); // Ensure UserID is string\r\n                    const nameForFilename = data.Is_Company ? data.Company_Name : `${data.First_Name?.charAt(0)} ${data.Last_Name}`;\r\n                    const letterTypeMap = letterTypes(data.a ?? [], data.enforcename ?? 'UnknownAgency', nameForFilename ?? 'UnknownName', userId); // Provide defaults\r\n\r\n                    const templateMeta = props.templates?.find((template: { kind: any; }) => template.kind === data.kind);\r\n\r\n                    if (!templateMeta) {\r\n                        console.warn(`No template found for kind: ${data.kind}`);\r\n                        continue; // Skip if no template\r\n                    }\r\n\r\n                    const letterTypeName = templateMeta.letter as keyof typeof letterTypeMap;\r\n                    const specificLetterType = letterTypeMap[letterTypeName];\r\n\r\n                    if (!specificLetterType) {\r\n                        console.warn(`No letter type definition found for: ${letterTypeName}`);\r\n                        continue; // Skip if no definition\r\n                    }\r\n\r\n                    // Calculate selected obligation value\r\n                    data.selectedObValue = '$' + formatMoney((data.a ?? []).reduce((t: number, o: ObligationRowData) => t + Number(String(o.Balance_Outstanding || '0').replace(/[^0-9.-]+/g, \"\")), 0));\r\n\r\n                    // Add dynamic properties based on letter type Props\r\n                    if (specificLetterType.Props) {\r\n                        const dates = getDates(); // Get dates once if needed\r\n                        specificLetterType.Props.forEach(prop => {\r\n                            data[prop] = true; // Default value\r\n                            if (prop === \"todayplus14\") data[prop] = dates.todayplus14;\r\n                            if (prop === \"todayplus28\") data[prop] = dates.todayplus28;\r\n                            if (prop === \"todayplus21\") data[prop] = dates.todayplus21;\r\n                            // Add other specific prop handlers if necessary\r\n                        });\r\n                    }\r\n\r\n                    // Resolve the template promise before calling makeLetter\r\n                    const templateBuffer = await templateMeta.template;\r\n\r\n                    // Assuming makeLetter matches the inferred type\r\n                    (makeLetter as MakeLetterType)(data, templateBuffer, specificLetterType.filename);\r\n\r\n                    // Email generation logic (ensure emailMaker is defined and typed)\r\n                    if (data.MOU === true &&\r\n                        !props.letters.some((type: string) => type === 'Agency Fee Removal' || type === \"Notice of Deregistration\")) {\r\n                        const agencyTemplateMeta = props.templates?.find((template: { kind: string; }) => template.kind === 'Agency');\r\n                        if (agencyTemplateMeta) {\r\n                            emailMaker(data, [data.AgencyEmail, 'MOU', agencyTemplateMeta.letter]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            } catch (error) {\r\n                console.error(\"Error during afterAction processing:\", error);\r\n                // Rethrow or handle as appropriate\r\n                throw error;\r\n            } finally {\r\n                running = false; // Ensure lock is always reset\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// --- Helper Functions with Types ---\r\n\r\nfunction getAppData(data: any): Promise<Record<string, any[]>> { // Improve 'any' if possible\r\n    return new Promise((resolve, reject) => {\r\n        chrome.storage.local.get(['value'], (items: ChromeStorageData) => {\r\n            if (chrome.runtime.lastError) {\r\n                console.error(chrome.runtime.lastError.message);\r\n                return reject(chrome.runtime.lastError);\r\n            }\r\n            const applicationData = items.value ?? {};\r\n            data.tParty = false; // Default\r\n            data.legalCentre = false; // Default\r\n\r\n            for (const applicationKey in applicationData) {\r\n                const appDetails = applicationData[applicationKey];\r\n                // Check array length before accessing indices\r\n                if (Array.isArray(appDetails) && appDetails.length > 18 && appDetails[0] === data.Debtor_ID) {\r\n                    data.legalCentre = false; // Reset per application check\r\n                    if (appDetails[1] === true) { // Assuming index 1 indicates tParty status\r\n                        data.tParty = true;\r\n                        data.applicantName = appDetails[2];\r\n                        data.appOrganisation = appDetails[3];\r\n                        data.appStreet = appDetails[4];\r\n                        data.appTown = appDetails[5];\r\n                        data.appState = appDetails[6];\r\n                        data.appPost = appDetails[7];\r\n                        data.legalCentre = appDetails[17]; // Potential Legal Centre flag for main 3rd party\r\n\r\n                        // Determine recipient based on flags at indices 8, 9, 10\r\n                        if (appDetails[8] === true) {\r\n                            data.recipient = '3rd Party';\r\n                        } else if (appDetails[9] === true) {\r\n                            data.recipient = 'Debtor';\r\n                        } else if (appDetails[10] === true) {\r\n                            data.recipient = 'Alt 3rd Party';\r\n                            data.altApplicantName = appDetails[11];\r\n                            data.altAppOrganisation = appDetails[12];\r\n                            data.altAppStreet = appDetails[13];\r\n                            data.altAppTown = appDetails[14];\r\n                            data.altAppState = appDetails[15];\r\n                            data.altAppPost = appDetails[16];\r\n                            // Assuming index 18 is the legal centre flag specifically for Alt 3rd Party\r\n                            data.legalCentre = appDetails[18]; // Overwrite if Alt 3rd party is chosen\r\n                        } else {\r\n                            // Default recipient if no flag is set?\r\n                            data.recipient = 'Unknown'; // Or Debtor/3rd Party based on data.tParty?\r\n                        }\r\n                        break; // Found matching debtor, stop searching\r\n                    } else {\r\n                        // Debtor ID matched, but tParty flag (index 1) is false\r\n                        data.tParty = false;\r\n                        // Potentially break here too if only one entry per Debtor_ID is expected\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // Resolve with the original retrieved items.value structure\r\n            resolve(items.value ?? {});\r\n        });\r\n    });\r\n}\r\n\r\n\r\nfunction loadLetter(url: string): Promise<ArrayBuffer> {\r\n    return new Promise((resolve, reject) => {\r\n        JSZipUtils.getBinaryContent(url, (err, data) => {\r\n            if (err) {\r\n                console.error(\"Error loading letter template:\", err);\r\n                running = false; // Reset lock on error\r\n                reject(err);\r\n            } else {\r\n                resolve(data);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nconst addressPriority: string[] = [\"Postal Address\", \"Residential Address\", \"Unknown Address\"];\r\n\r\nconst challengeList: Record<string, string> = {\r\n    \"E_EXCIRCUM\": \"Exceptional circumstances\",\r\n    \"E_PERUNAWR\": \"Person unaware\",\r\n    \"E_SPCIRCUM\": \"Special circumstances\",\r\n    \"E_CONTRLAW\": \"Contrary to the law\",\r\n    \"E_MISTAKID\": \"Mistake of identity\"\r\n};\r\n\r\n// Ensure all keys used in code exist here\r\nconst letterURL: Record<string, string> = {\r\n    'Agency Enforcement Cancelled': \"21860542\",\r\n    'Agency Fee Removal': \"12918361\",\r\n    'Enforcement Confirmed': \"21908189\",\r\n    'Enforcement Cancelled': \"21864380\",\r\n    \"ER Confirm/ FW Grant\": \"21922728\",\r\n    'Report Needed': \"12918375\",\r\n    'Wrong person applying. No grounds': \"12918368\",\r\n    'Paid in full. Ineligible': \"12918367\",\r\n    'Outside Person Unaware. Ineligible': \"12918370\", // Used twice in original JS? Check logic\r\n    'Offence n/e Person Unaware. No grounds': \"12918370\", // Used twice in original JS? Check logic\r\n    'Unable to Contact Applicant': \"12918377\",\r\n    'Claim of payment adv contact agency': \"14513448\",\r\n    'Notice of Deregistration': \"14688539\",\r\n    'Further Information Required': \"15102090\",\r\n    'FVS Eligible Debtor': \"15104893\",\r\n    'FVS Eligible Agency': \"15104895\",\r\n    'FVS Ineligible': \"15111337\",\r\n    'FVS Further Information Required': \"15111404\",\r\n    'PSL': \"15119430\",\r\n    'Suspension of driver licence': \"15531068\",\r\n    \"Suspension of vehicle registration - Ind\": \"17470564\",\r\n    \"Suspension of vehicle registration - Corp\": \"17470563\",\r\n    'Court Fine Fee Waive Granted': \"EXKiK2Ln98ZFq1RNxyVlAuIB9XFcwmEu0u-wn-u9xLRaeg\", // Different format?\r\n    \"Special Circumstances No grounds\": \"18754905\", // Duplicate key? Check logic\r\n    \"POI - direction to produce\": \"21266650\",\r\n    \"PA Refused - Active 7DN\": \"21379969\",\r\n    \"No Grounds\": \"21781572\", // Duplicate key? Check logic\r\n    \"PA Refused\": \"21780824\",\r\n    \"EOT Refused\": \"21781515\",\r\n    \"PA Refused-Sanction\": \"21538164\",\r\n    \"PA App Incomplete\": \"21543595\",\r\n    \"Company PA Ineligible SZWIP\": \"21543668\",\r\n    \"EOT Refused - Infringements stage\": \"21547909\",\r\n    \"PA Refused Expired 7DN\": \"21554295\",\r\n    \"Fee Removal PIF\": \"21569882\",\r\n    \"CF Fee Removal Granted\": \"21588427\",\r\n    \"CF Fee Removal Refused\": \"21623835\",\r\n    'Fee Removal Refused': \"21625790\", // Duplicate key? Check logic\r\n    'FR Refused - Active 7DN': \"21630687\",\r\n    'FW Refused - Sanction': \"21642104\",\r\n    \"FR Granted\": \"21602358\",\r\n    \"Agency FR Granted\": \"21609844\",\r\n    \"FR Granted - Active 7DN\": \"21575815\",\r\n    \"FR Granted - Sanction\": \"21582960\",\r\n    \"Ineligible for ER - offence type\": \"21720126\",\r\n    \"Court not an option\": \"21746214\",\r\n    \"ER Ineligible Deregistered Company\": \"21758558\",\r\n    \"Ineligible Paid in full\": \"21761625\", // Duplicate key? Check logic\r\n    \"Appeal not available\": \"21761877\",\r\n    \"Nomination Not Grounds\": \"21767490\",\r\n    \"ER Ineligible Court Fine\": \"21771157\",\r\n    \"Spec Circ Options\": \"21774656\",\r\n    \"ER Additional Info\": \"21738969\",\r\n    \"Ineligible for ER enforcement action\": \"21745145\",\r\n    \"Ineligible PU - Outside Time\": \"21787906\",\r\n    \"Ineligible for ER previous review\": \"21790863\",\r\n    \"ER Ineligible PU\": \"21794412\",\r\n    \"Claim of payment to agency\": \"21797592\", // Duplicate key? Check logic\r\n    \"Request for photo evidence\": \"21811532\",\r\n    \"Ineligible Incorrect company applying\": \"21815023\",\r\n    \"Spec Circ No Grounds\": \"21825433\", // Duplicate key? Check logic\r\n    \"Spec Circ Report Required\": \"21827269\",\r\n    \"Unauthorised 3rd party applying\": \"21834939\",\r\n    \"Ineligible Incorrect person applying\": \"21846719\",\r\n    \"Spec Circ App Required\": \"21976745\",\r\n    \"Spec Circ Report Insufficient\": \"21979090\",\r\n    \"SC 3P Lawyer - Report Insufficient\": \"21977719\",\r\n    \"ER Application Incomplete\": \"21982730\",\r\n    \"SC 3P Lawyer - Report Required\": \"21991100\",\r\n    \"ER Confirm/FW Grant - Active 7DN\": \"21993681\",\r\n    \"ER Confirm/FW Grant - 7DN Expired option\": \"21993728\",\r\n    // Add any missing ones like 'Agency Enforcement Cancelled Updated' if needed\r\n    'Agency Enforcement Cancelled Updated': \"MISSING_ID\", // Placeholder\r\n};\r\n\r\nfunction padTo2Digits(num: number): string {\r\n    return num.toString().padStart(2, '0');\r\n}\r\n\r\nfunction formatDate(date: Date = new Date()): string {\r\n    return [\r\n        date.getFullYear(),\r\n        padTo2Digits(date.getMonth() + 1), // Month is 0-indexed\r\n        padTo2Digits(date.getDate()),\r\n    ].join('');\r\n}\r\n\r\n// Returns a map of letter names to their definitions (filename, props)\r\nfunction letterTypes(\r\n    obligationRows: ObligationRowData[],\r\n    enforcename: string,\r\n    name: string,\r\n    UserID: string\r\n): Record<string, LetterTypeDef> {\r\n    const o = obligationRows ?? [];\r\n    const OBL = o.length === 1 ? \" OBL \" + o[0]?.Obligation : \" x \" + o.length;\r\n    const firstChallenge = o[0]?.Challenge;\r\n    const ReviewType = firstChallenge === \"Special circumstances\" ? \"ER Special\" : firstChallenge !== undefined ? \"ER General\" : undefined;\r\n    const dt = formatDate(); // Calculate date once\r\n\r\n    // Build the map directly\r\n    const types: Record<string, LetterTypeDef> = {\r\n        'Agency Enforcement Cancelled': { filename: `${enforcename} - Cancelled${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Agency Fee Removal': { filename: `${enforcename} - Fee Removal - Granted${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Enforcement Confirmed': { filename: `${ReviewType ?? 'Review'} - Confirmed${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Enforcement Cancelled': { filename: `${ReviewType ?? 'Review'} - Cancelled${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'ER Confirm/ FW Grant': { filename: `${ReviewType ?? 'Review'} - Confirmed With Fee Removal - Granted${OBL} ${name} - ${UserID} - ${dt}`, Props: [\"ECCV\"] },\r\n        'Report Needed': { filename: `Report Needed${OBL} ${name} - ${UserID} - ${dt}`, Props: [\"todayplus14\"] },\r\n        'Further Information Required': { filename: `Further Information Required${OBL} ${name} - ${UserID} - ${dt}`, Props: [\"todayplus14\"] },\r\n        'Wrong person applying. No grounds': { filename: `No Grounds${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Paid in full. Ineligible': { filename: `Paid In Full${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Outside Person Unaware. Ineligible': { filename: `Outside Person Unware${OBL} ${name} - ${UserID} - ${dt}`, Props: [\"Person_unaware_1\"] },\r\n        'Offence n/e Person Unaware. No grounds': { filename: `No Grounds Person Unware${OBL} ${name} - ${UserID} - ${dt}`, Props: [\"Person_unaware_2\"] },\r\n        'Unable to Contact Applicant': { filename: `Unable To Contact Applicant${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Special Circumstances No grounds': { filename: `No Grounds${OBL} ${name} - ${UserID} - ${dt}` }, // Duplicate?\r\n        'Claim of payment adv contact agency': { filename: `Cont Agency${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Notice of Deregistration': { filename: `Notice Of Deregistration${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'FVS Eligible Debtor': { filename: `${name} - FVS Eligible${OBL}`, Props: [\"todayplus28\"] },\r\n        'FVS Eligible Agency': { filename: `${name} - ${enforcename} - FVS Eligible${OBL}` },\r\n        'FVS Ineligible': { filename: `${name} - ${enforcename} - FVS Ineligible${OBL}` },\r\n        'FVS Further Information Required': { filename: `${name} - ${enforcename} - FVS Further Information Required${OBL}`, Props: [\"todayplus21\"] },\r\n        'Suspension of driver licence': { filename: `${name} - Suspension of driver licence${OBL}` },\r\n        'Suspension of vehicle registration - Ind': { filename: `${name} - Suspension of vehicle registration${OBL}` },\r\n        'Suspension of vehicle registration - Corp': { filename: `${name} - Suspension of vehicle registration${OBL}` },\r\n        'PSL': { filename: `${name} - PSL${OBL}` },\r\n        'Court Fine Fee Waive Granted': { filename: `Court Fine - Fee Removal - Granted${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'POI - direction to produce': { filename: `${name} - POI - direction to produce${OBL}`, Props: [\"todayplus28\"] },\r\n        'PA Refused - Active 7DN': { filename: `${name} - PA Refused - Active 7DN${OBL}`, Props: [\"todayplus28\"] },\r\n        'No Grounds': { filename: `No Grounds${OBL} ${name} - ${UserID} - ${dt}`, Props: [\"No_Grounds\"] }, // Duplicate?\r\n        'PA Refused': { filename: `PA Refused${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'EOT Refused': { filename: `EOT Refused${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'PA Refused-Sanction': { filename: `PA Refused-Sanction${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'PA App Incomplete': { filename: `PA App Incomplete${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Company PA Ineligible SZWIP': { filename: `Company PA Ineligible SZWIP${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'EOT Refused - Infringements stage': { filename: `EOT Refused - Infringements stage${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'PA Refused Expired 7DN': { filename: `PA Refused Expired 7DN${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Fee Removal PIF': { filename: `Fee Removal PIF${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'CF Fee Removal Granted': { filename: `CF Fee Removal Granted${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'CF Fee Removal Refused': { filename: `CF Fee Removal Refused${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Fee Removal Refused': { filename: `Fee Removal Refused${OBL} ${name} - ${UserID} - ${dt}` }, // Duplicate?\r\n        'FR Refused - Active 7DN': { filename: `FR Refused - Active 7DN${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'FW Refused - Sanction': { filename: `FW Refused - Sanction${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'FR Granted': { filename: `FR Granted${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Agency FR Granted': { filename: `${enforcename} - Agency FR Granted${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'FR Granted - Active 7DN': { filename: `FR Granted - Active 7DN${OBL} ${name} - ${UserID} - ${dt}` }, // Enforce name was here?\r\n        'FR Granted - Sanction': { filename: `FR Granted - Sanction${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Ineligible for ER - offence type': { filename: `Ineligible for ER - offence type${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Court not an option': { filename: `Court not an option${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'ER Ineligible Deregistered Company': { filename: `ER Ineligible Deregistered Company${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Ineligible Paid in full': { filename: `Ineligible Paid in full${OBL} ${name} - ${UserID} - ${dt}` }, // Duplicate?\r\n        'Appeal not available': { filename: `Appeal not available${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Nomination Not Grounds': { filename: `Nomination Not Grounds${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'ER Ineligible Court Fine': { filename: `ER Ineligible Court Fine${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Spec Circ Options': { filename: `Spec Circ Options${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'ER Additional Info': { filename: `ER Additional Info${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Ineligible for ER enforcement action': { filename: `Ineligible for ER enforcement action${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Ineligible PU - Outside Time': { filename: `Ineligible PU - Outside Time${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Ineligible for ER previous review': { filename: `Ineligible for ER previous review${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'ER Ineligible PU': { filename: `ER Ineligible PU${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Claim of payment to agency': { filename: `Claim of payment to agency${OBL} ${name} - ${UserID} - ${dt}` }, // Duplicate?\r\n        'Request for photo evidence': { filename: `Request for photo evidence${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Ineligible Incorrect company applying': { filename: `Ineligible Incorrect company applying${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Spec Circ No Grounds': { filename: `Spec Circ No Grounds${OBL} ${name} - ${UserID} - ${dt}` }, // Duplicate?\r\n        'Spec Circ Report Required': { filename: `Spec Circ Report Required${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Unauthorised 3rd party applying': { filename: `Unauthorised 3rd party applying${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Ineligible Incorrect person applying': { filename: `Ineligible Incorrect person applying${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Spec Circ App Required': { filename: `Spec Circ App Required${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'Spec Circ Report Insufficient': { filename: `Spec Circ Report Insufficient${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'SC 3P Lawyer - Report Insufficient': { filename: `SC 3P Lawyer - Report Insufficient${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'ER Application Incomplete': { filename: `ER Application Incomplete${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'SC 3P Lawyer - Report Required': { filename: `SC 3P Lawyer - Report Required${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'ER Confirm/FW Grant - Active 7DN': { filename: `ER Confirm/FW Grant - Active 7DN${OBL} ${name} - ${UserID} - ${dt}` },\r\n        'ER Confirm/FW Grant - 7DN Expired option': { filename: `ER Confirm/FW Grant - 7DN Expired option${OBL} ${name} - ${UserID} - ${dt}` },\r\n        // Add any missing letter types referenced elsewhere\r\n        'Agency Enforcement Cancelled Updated': { filename: `${enforcename} - Cancelled Updated${OBL} ${name} - ${UserID} - ${dt}` }, // Example\r\n    };\r\n\r\n    return types;\r\n}\r\n\r\n// Generic types T and U, K is key property name\r\nfunction mergeById<\r\n    // IDType: The type of the property used for matching (e.g., string, number)\r\n    IDType extends PropertyKey, // PropertyKey is string | number | symbol\r\n    K extends PropertyKey,      // Type of the key in T\r\n    L extends PropertyKey,      // Type of the key in U\r\n    // T may have an optional property K of type IDType\r\n    T extends { [P in K]?: IDType },\r\n    // U must have a property L of type IDType\r\n    U extends Record<L, IDType>\r\n>(\r\n    a1: T[],\r\n    a2: U[],\r\n    property1: K,\r\n    property2: L\r\n    // The return type implies all items from a1 are returned,\r\n    // potentially merged with properties from a matching U item.\r\n    // Using Partial<U> because a match isn't guaranteed for every T.\r\n): (T & Partial<U>)[] {\r\n\r\n    // Create a Map for efficient lookups based on property2 values from a2\r\n    const mapU = new Map<IDType, U>();\r\n    for (const item of a2) {\r\n        // Ensure item has the property before setting\r\n        if (Object.prototype.hasOwnProperty.call(item, property2)) {\r\n            mapU.set(item[property2], item);\r\n        }\r\n    }\r\n\r\n    return a1.map(itm => {\r\n        // Look up the corresponding item from a2 using the map\r\n        // Skip undefined properties\r\n        const propValue = itm[property1];\r\n        if (propValue === undefined) {\r\n            return itm as T & Partial<U>;\r\n        }\r\n        const matchingItem = mapU.get(propValue as IDType);\r\n\r\n        // Spread itm first, then add/override with properties from matchingItem if it exists.\r\n        // If matchingItem is undefined, spreading it results in no added properties.\r\n        // The type assertion `{} as U` is no longer needed due to Partial<U> return type.\r\n        return { ...itm, ...(matchingItem ?? {}) };\r\n    });\r\n}\r\n\r\nfunction toTitleCase(str: string): string {\r\n    if (!str) return \"\";\r\n    return str.replace(\r\n        /\\w\\S*/g,\r\n        (txt) => txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase()\r\n    );\r\n}\r\n\r\nfunction toTitleCaseHypen(str: string): string {\r\n    if (!str) return \"\";\r\n    return str.toLowerCase().replace(/(?:^|\\s|\\/|-)\\w/g, (match) => match.toUpperCase());\r\n}\r\n\r\n// Specify return type more accurately if known (e.g., string | number | undefined)\r\nfunction getData(sKey: keyof ChromeStorageData): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.storage.local.get(sKey, (items: Partial<ChromeStorageData>) => {\r\n            if (chrome.runtime.lastError) {\r\n                console.error(chrome.runtime.lastError.message);\r\n                reject(chrome.runtime.lastError);\r\n            } else {\r\n                resolve(items[sKey]);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n// --- HTML Table Parsing Utilities ---\r\n\r\nfunction mapRow(headings: string[]): (row: HTMLTableRowElement) => ParsedTableRow {\r\n    return ({ cells }: HTMLTableRowElement): ParsedTableRow => {\r\n        return Array.from(cells).reduce((result, cell, i) => {\r\n            const input = cell.querySelector<HTMLInputElement | HTMLSelectElement>(\"input,select\");\r\n            let value: string | boolean;\r\n\r\n            if (input) {\r\n                value = input.type === \"checkbox\" ? (input as HTMLInputElement).checked : input.value;\r\n            } else {\r\n                // Use textContent for potentially better consistency than innerText\r\n                value = cell.textContent?.trim() ?? '';\r\n            }\r\n\r\n            // Use heading if available, otherwise use index as key\r\n            const key = headings[i] ?? `column_${i}`;\r\n            result[key] = String(value); // Convert boolean/number to string for consistency? Or allow mixed types? Let's keep string for now.\r\n            return result;\r\n        }, {} as ParsedTableRow);\r\n    };\r\n}\r\n\r\nexport function parseTable(table: HTMLTableElement | null): ParsedTableRow[] {\r\n    if (!table?.tHead?.rows?.[0]?.cells || !table?.tBodies?.[0]?.rows) {\r\n        console.warn(\"Table structure incomplete for parsing:\", table);\r\n        return [];\r\n    }\r\n    // Header parsing with robust check and fallback\r\n    const headings = Array.from(table.tHead.rows[0].cells).map(\r\n        heading => (heading.textContent ?? '').replace(/  \\d|  \\d/g, \"\").trim() // Use textContent and trim\r\n    );\r\n    // Body parsing with robust check\r\n    return Array.from(table.tBodies[0].rows).map(mapRow(headings));\r\n}\r\n\r\n\r\nfunction convertArrayToObject<T extends Record<string, any>>(array: T[], key: keyof T): Record<string, T> {\r\n    const initialValue: Record<string, T> = {};\r\n    return array.reduce((obj, item) => {\r\n        const keyValue = String(item[key]); // Ensure key is a string\r\n        obj[keyValue] = item;\r\n        return obj;\r\n    }, initialValue);\r\n}\r\n\r\n\r\nfunction groupBy(arr: any[], property: string) {\r\n    return arr.reduce(function (memo, x) {\r\n        console.log()\r\n        if (!memo.some((item: { [x: string]: any; }) => item[property] === x[property])) { memo.push({ [property]: x[property], a: [] }) }\r\n        memo.map((itm: { [x: string]: any; a: any[]; }) => itm[property] === x[property] && itm.a.push(x))\r\n        return memo;\r\n    }, []);\r\n}\r\n\r\nfunction formatMoney(amount: number | string | null | undefined, decimalCount: number = 2, decimal: string = \".\", thousands: string = \",\"): string {\r\n    try {\r\n        decimalCount = Math.abs(decimalCount);\r\n        decimalCount = isNaN(decimalCount) ? 2 : decimalCount;\r\n\r\n        const amountNum = Math.abs(Number(amount) || 0); // Ensure number and positive\r\n        const negativeSign = Number(amount) < 0 ? \"-\" : \"\";\r\n\r\n        const i = parseInt(amountNum.toFixed(decimalCount), 10).toString();\r\n        const j = i.length > 3 ? i.length % 3 : 0;\r\n\r\n        return (\r\n            negativeSign +\r\n            (j ? i.substring(0, j) + thousands : '') +\r\n            i.substring(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + thousands) +\r\n            (decimalCount ? decimal + Math.abs(amountNum - parseInt(i, 10)).toFixed(decimalCount).slice(2) : \"\")\r\n        );\r\n    } catch (e) {\r\n        console.error(\"Error formatting money:\", e);\r\n        return String(amount ?? ''); // Return original string or empty on error\r\n    }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { launch } from \"./js/letter-logic\";\nlet running = false;\n\nchrome.runtime.onMessage.addListener(\n    async function (message, sender, sendResponse) {\n        if (sender.url.toUpperCase().includes(`https://${message[5]}.view.civicacloud.com.au/Traffic/Debtors/Forms/DebtorObligations`.toUpperCase()) &&\n            !message[1].includes('Bulk') && !message[1].includes('Export') &&\n            message[4] === false) {\n            const properties = {};\n            properties.obligationRows = message[6];\n            properties.source = message[5];\n            properties.agency = message[7];\n            properties.letters = message[8];\n            properties.extended = message[9];\n            properties.SharePoint = message[10];\n            launch(properties);\n        }\n    }\n);"],"names":["_regeneratorRuntime","e","t","r","Object","prototype","n","hasOwnProperty","o","defineProperty","value","i","Symbol","a","iterator","c","asyncIterator","u","toStringTag","define","enumerable","configurable","writable","wrap","Generator","create","Context","makeInvokeMethod","tryCatch","type","arg","call","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","d","getPrototypeOf","v","values","g","defineIteratorMethods","forEach","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","then","callInvokeWithMethodAndArg","Error","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","isNaN","length","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","_catch","delegateYield","asyncGeneratorStep","_asyncToGenerator","arguments","apply","_next","_throw","launch","running","chrome","runtime","onMessage","addListener","_ref","_callee","message","sender","sendResponse","properties","_callee$","_context","url","toUpperCase","includes","concat","obligationRows","source","agency","letters","extended","SharePoint","_x","_x2","_x3"],"sourceRoot":""}